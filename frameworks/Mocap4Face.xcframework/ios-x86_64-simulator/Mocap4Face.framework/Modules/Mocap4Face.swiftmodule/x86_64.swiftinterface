// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4.2 (swiftlang-1205.0.28.2 clang-1205.0.19.57)
// swift-module-flags: -target x86_64-apple-ios11.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Mocap4Face
import CoreMedia
import CoreVideo
import Foundation
import Metal
import MetalKit

import Swift
import UIKit
import VideoToolbox
extension UIColor {
  public var rgbComponents: (red: CoreGraphics.CGFloat, green: CoreGraphics.CGFloat, blue: CoreGraphics.CGFloat, alpha: CoreGraphics.CGFloat) {
    get
  }
}
extension Int {
  public var n: Swift.Float {
    get
  }
}
extension Float {
  public var n: Swift.Float {
    get
  }
}
extension Double {
  public var n: Swift.Float {
    get
  }
}
extension FacemojiAPIClass {
  @discardableResult
  public func initialize(_ apiKey: Swift.String) -> Mocap4Face.Future<Swift.Bool>
}
public class KotlinError : Foundation.LocalizedError, Swift.CustomStringConvertible {
  final public let exception: Mocap4Face.KotlinException
  public init(_ exception: Mocap4Face.KotlinException)
  public var errorDescription: Swift.String? {
    get
  }
  public var description: Swift.String {
    get
  }
  @objc deinit
}
extension Try {
  public func rethrow() throws -> T
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers public class MetalTextureView : MetalKit.MTKView {
  public enum Rotation : Swift.Int {
    case rotate0Degrees
    case rotate90Degrees
    case rotate180Degrees
    case rotate270Degrees
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
  public var mirrorHorizontally: Swift.Bool {
    get
    set
  }
  public var imageFill: Mocap4Face.FillMode
  public var pixelBuffer: CoreVideo.CVPixelBuffer? {
    get
    set
  }
  public func setSampleBuffer(_ sampleBuffer: CoreMedia.CMSampleBuffer)
  public func setPixelBuffer(_ newBuffer: CoreVideo.CVPixelBuffer)
  @objc override dynamic public func draw(_ rect: CoreGraphics.CGRect)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KotlinObjectWrapper {
  @objc deinit
}
public protocol ConvertibleToKotlin {
  init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  func asKotlin() -> Swift.AnyObject
}
public func listOf<T>(_ items: T...) -> [T]
public func floatArrayOf(_ items: Swift.Float...) -> [Swift.Float]
public func intArrayOf(_ items: Swift.Int...) -> [Swift.Int]
public func doubleArrayOf(_ items: Swift.Double...) -> [Swift.Double]
public func floatArrayOf(_ items: Swift.Float...) -> Mocap4Face.KotlinFloatArray
public func intArrayOf(_ items: Swift.Int...) -> Mocap4Face.KotlinIntArray
public func doubleArrayOf(_ items: Swift.Double...) -> Mocap4Face.KotlinDoubleArray
public func assert(_ condition: Swift.Bool)
public func codePointAt(_ seq: Any, _ index: Swift.Int) -> Swift.Int
public func toCodePoint(_ high: Foundation.unichar, _ low: Foundation.unichar) -> Swift.Int
public func isSurrogatePair(_ high: Foundation.unichar, _ low: Foundation.unichar) -> Swift.Bool
public func vectorLerp<T>(_ transition: @escaping (Swift.Float) -> Swift.Float = linearTransition) -> (Swift.Float, T, T, Mocap4Face.AnimatorKey<T>?, Mocap4Face.AnimatorKey<T>?) -> T where T : Mocap4Face.Vec
public func quaternionLerp(_ transition: @escaping (Swift.Float) -> Swift.Float = linearTransition) -> (Swift.Float, Mocap4Face.Quaternion, Mocap4Face.Quaternion, Mocap4Face.AnimatorKey<Mocap4Face.Quaternion>?, Mocap4Face.AnimatorKey<Mocap4Face.Quaternion>?) -> Mocap4Face.Quaternion?
public func quaternionSlerp() -> (Swift.Float, Mocap4Face.Quaternion, Mocap4Face.Quaternion, Mocap4Face.AnimatorKey<Mocap4Face.Quaternion>?, Mocap4Face.AnimatorKey<Mocap4Face.Quaternion>?) -> Mocap4Face.Quaternion
public func quaternionSpline() -> (Swift.Float, Mocap4Face.Quaternion, Mocap4Face.Quaternion, Mocap4Face.AnimatorKey<Mocap4Face.Quaternion>?, Mocap4Face.AnimatorKey<Mocap4Face.Quaternion>?) -> Mocap4Face.Quaternion
public func numArrayOf(_ elements: Mocap4Face.KotlinDoubleArray) -> Mocap4Face.KotlinFloatArray
public func numArrayOf(_ elements_: Mocap4Face.KotlinFloatArray) -> Mocap4Face.KotlinFloatArray
public func numArrayOf(_ elements__: Mocap4Face.KotlinIntArray) -> Mocap4Face.KotlinFloatArray
public func min<T>(_ a: T, _ b: T) -> T where T : Mocap4Face.Vec
public func max<T>(_ a: T, _ b: T) -> T where T : Mocap4Face.Vec
public func tuple<T0>(_ _0: T0) -> Mocap4Face.Tuple1<T0>
public func tuple<T0, T1>(_ _0: T0, _ _1: T1) -> Mocap4Face.Tuple2<T0, T1>
public func tuple<T0, T1, T2>(_ _0: T0, _ _1: T1, _ _2: T2) -> Mocap4Face.Tuple3<T0, T1, T2>
public func tuple<T0, T1, T2, T3>(_ _0: T0, _ _1: T1, _ _2: T2, _ _3: T3) -> Mocap4Face.Tuple4<T0, T1, T2, T3>
public func tuple<T0, T1, T2, T3, T4>(_ _0: T0, _ _1: T1, _ _2: T2, _ _3: T3, _ _4: T4) -> Mocap4Face.Tuple5<T0, T1, T2, T3, T4>
public func tuple<T0, T1, T2, T3, T4, T5>(_ _0: T0, _ _1: T1, _ _2: T2, _ _3: T3, _ _4: T4, _ _5: T5) -> Mocap4Face.Tuple6<T0, T1, T2, T3, T4, T5>
public func tuple<T0, T1, T2, T3, T4, T5, T6>(_ _0: T0, _ _1: T1, _ _2: T2, _ _3: T3, _ _4: T4, _ _5: T5, _ _6: T6) -> Mocap4Face.Tuple7<T0, T1, T2, T3, T4, T5, T6>
public func tuple<T0, T1, T2, T3, T4, T5, T6, T7>(_ _0: T0, _ _1: T1, _ _2: T2, _ _3: T3, _ _4: T4, _ _5: T5, _ _6: T6, _ _7: T7) -> Mocap4Face.Tuple8<T0, T1, T2, T3, T4, T5, T6, T7>
public func flazy<T, TKotlinLazy>(_ initializer: @escaping () -> T) -> TKotlinLazy where T == TKotlinLazy.T, TKotlinLazy : Mocap4Face.KotlinLazy
public func stacktrace(_ e: Mocap4Face.KotlinException) -> Swift.String
public func threadSleep(_ milliseconds: Swift.Int)
public func runInThread(_ fn: @escaping () -> Swift.Void)
public func freezeObject<T>(_ o: T) -> T
public func forbidFreezing<T>(_ o: T) -> T
public func isMainThread() -> Swift.Bool
public func threadId() -> Swift.Int64
public func checkMutexLock(_ result: Swift.Int)
public func checkCondWait(_ result: Swift.Int)
public func deserializeResult(_ data: Mocap4Face.KotlinByteArray) -> Mocap4Face.KotlinPair<Mocap4Face.FaceTrackerResult, Mocap4Face.KotlinByteArray?>
public func netOutputToTrackerNetResult(_ outputs: Mocap4Face.Try<Mocap4Face.NeuralNetOutput>, _ model: Mocap4Face.CoreMLModel, _ blendshapeNames: [Swift.String]) -> Mocap4Face.Try<Mocap4Face.TrackerNetResult>
extension File {
  public func readLines() -> Mocap4Face.Future<Mocap4Face.Try<[Swift.String]>>
}
public func imageFromBytes(_ bytes: Mocap4Face.KotlinByteArray) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.Image>>
public func uiImageFromBytes(_ bytes: Mocap4Face.KotlinByteArray) -> Mocap4Face.Try<Mocap4Face.UIKitImage>
extension FileSystem {
  public func subSystem(_ root: Mocap4Face.Path) -> Mocap4Face.FileSystem
}
extension WriteableFileSystem {
  public func subSystem(_ root_: Mocap4Face.Path) -> Mocap4Face.WriteableFileSystem
}
extension FileSystem {
  public func indexed(_ indexReloadIntervalMs: Swift.Int = 60 * 60 * 1000) -> Mocap4Face.FileSystem
}
extension WriteableFileSystem {
  public func indexed(_ indexReloadIntervalMs_: Swift.Int = 60 * 60 * 1000) -> Mocap4Face.WriteableFileSystem
}
extension FileSystem {
  public func textAt(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Swift.String>>
}
extension FileSystem {
  public func watch(_ watchFilter: ((Swift.String) -> Swift.Bool)? = nil, _ errorSensitivity: Mocap4Face.FileWatchErrorSensitivity = .medium) -> Mocap4Face.FileSystemWatch
}
extension File {
  public func watch(_ errorSensitivity: Mocap4Face.FileWatchErrorSensitivity = .medium) -> Mocap4Face.FileWatch
}
extension FileSystem {
  public func watcher(_ watchFilter: ((Swift.String) -> Swift.Bool)? = nil, _ errorSensitivity: Mocap4Face.FileWatchErrorSensitivity = .medium) -> Mocap4Face.FileSystemWatcher
}
extension File {
  public func watcher(_ errorSensitivity: Mocap4Face.FileWatchErrorSensitivity = .medium) -> Mocap4Face.FileWatcher
}
extension FileSystem {
  public func fileWatch(_ path: Mocap4Face.Path, _ errorSensitivity: Mocap4Face.FileWatchErrorSensitivity = .medium) -> Mocap4Face.FileWatch
}
extension FileSystem {
  public func fileWatch(_ path: Swift.String, _ errorSensitivity_: Mocap4Face.FileWatchErrorSensitivity = .medium) -> Mocap4Face.FileWatch
}
extension FileSystem {
  public func fileWatcher(_ path: Mocap4Face.Path, _ errorSensitivity: Mocap4Face.FileWatchErrorSensitivity = .medium) -> Mocap4Face.FileWatcher
}
extension FileSystem {
  public func fileWatcher(_ path: Swift.String, _ errorSensitivity_: Mocap4Face.FileWatchErrorSensitivity = .medium) -> Mocap4Face.FileWatcher
}
public func cacheDir(_ context: Mocap4Face.ApplicationContext) -> Mocap4Face.Path
public func developmentResourceDirs() -> Mocap4Face.KotlinArray<Swift.String>
public func applicationDataFileSystem(_ context: Mocap4Face.ApplicationContext) -> Mocap4Face.WriteableFileSystem?
public func defaultBundle() -> Foundation.Bundle
public func isServerAvailable(_ address: Swift.String) -> Mocap4Face.Future<Swift.Bool>
public func parseHttpDate(_ date: Swift.String) -> Mocap4Face.Try<Swift.Int64>
public func developmentServer(_ port: Swift.String = "8000") -> Mocap4Face.Future<Swift.String?>
public func getTimeMillis() -> Swift.Int64
public var FACEMOJI_SDK_VERSION: Swift.String {
  get
}
public var linearTransition: (Swift.Float) -> Swift.Float {
  get
}
public var cosineTransition: (Swift.Float) -> Swift.Float {
  get
}
public var PIf: Swift.Float {
  get
}
public var PIn: Swift.Float {
  get
}
public var radianPerDegree: Swift.Float {
  get
}
public var degreePerRadian: Swift.Float {
  get
}
public var EXPRESSION_BLENDSHAPES: [Swift.String] {
  get
}
public protocol ReadBuf {
  var _wrappedReadBuf: Swift.AnyObject { get }
  func getBoolean(_ index: Swift.Int) -> Swift.Bool
  func get(_ index: Swift.Int) -> Swift.Int8
  func getShort(_ index: Swift.Int) -> Swift.Int16
  func getInt(_ index: Swift.Int) -> Swift.Int
  func getLong(_ index: Swift.Int) -> Swift.Int64
  func getFloat(_ index: Swift.Int) -> Swift.Float
  func getDouble(_ index: Swift.Int) -> Swift.Double
  func getString(_ start: Swift.Int, _ size: Swift.Int) -> Swift.String
  func data() -> Mocap4Face.KotlinByteArray
  func limit() -> Swift.Int
}
@_hasMissingDesignatedInitializers public class ReadBufWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.ReadBuf {
  public var _wrappedReadBuf: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func getBoolean(_ index: Swift.Int) -> Swift.Bool
  public func get(_ index: Swift.Int) -> Swift.Int8
  public func getShort(_ index: Swift.Int) -> Swift.Int16
  public func getInt(_ index: Swift.Int) -> Swift.Int
  public func getLong(_ index: Swift.Int) -> Swift.Int64
  public func getFloat(_ index: Swift.Int) -> Swift.Float
  public func getDouble(_ index: Swift.Int) -> Swift.Double
  public func getString(_ start: Swift.Int, _ size: Swift.Int) -> Swift.String
  public func data() -> Mocap4Face.KotlinByteArray
  public func limit() -> Swift.Int
  @objc deinit
}
public protocol ReadWriteBuf : Mocap4Face.ReadBuf {
  var _wrappedReadWriteBuf: Swift.AnyObject { get }
  func putBoolean(_ value: Swift.Bool)
  func put(_ value: Mocap4Face.KotlinByteArray, _ start: Swift.Int, _ length: Swift.Int)
  func put(_ value: Swift.Int8)
  func putShort(_ value: Swift.Int16)
  func putInt(_ value: Swift.Int)
  func putLong(_ value: Swift.Int64)
  func putFloat(_ value: Swift.Float)
  func putDouble(_ value: Swift.Double)
  func setBoolean(_ index: Swift.Int, _ value: Swift.Bool)
  func set(_ index: Swift.Int, _ value: Swift.Int8)
  func set(_ index: Swift.Int, _ value: Mocap4Face.KotlinByteArray, _ start: Swift.Int, _ length: Swift.Int)
  func setShort(_ index: Swift.Int, _ value: Swift.Int16)
  func setInt(_ index: Swift.Int, _ value: Swift.Int)
  func setLong(_ index: Swift.Int, _ value: Swift.Int64)
  func setFloat(_ index: Swift.Int, _ value: Swift.Float)
  func setDouble(_ index: Swift.Int, _ value: Swift.Double)
  func writePosition() -> Swift.Int
  func requestCapacity(_ capacity: Swift.Int) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class ReadWriteBufWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.ReadWriteBuf {
  public var _wrappedReadWriteBuf: Swift.AnyObject {
    get
  }
  public var _wrappedReadBuf: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func putBoolean(_ value: Swift.Bool)
  public func put(_ value: Mocap4Face.KotlinByteArray, _ start: Swift.Int, _ length: Swift.Int)
  public func put(_ value: Swift.Int8)
  public func putShort(_ value: Swift.Int16)
  public func putInt(_ value: Swift.Int)
  public func putLong(_ value: Swift.Int64)
  public func putFloat(_ value: Swift.Float)
  public func putDouble(_ value: Swift.Double)
  public func setBoolean(_ index: Swift.Int, _ value: Swift.Bool)
  public func set(_ index: Swift.Int, _ value: Swift.Int8)
  public func set(_ index: Swift.Int, _ value: Mocap4Face.KotlinByteArray, _ start: Swift.Int, _ length: Swift.Int)
  public func setShort(_ index: Swift.Int, _ value: Swift.Int16)
  public func setInt(_ index: Swift.Int, _ value: Swift.Int)
  public func setLong(_ index: Swift.Int, _ value: Swift.Int64)
  public func setFloat(_ index: Swift.Int, _ value: Swift.Float)
  public func setDouble(_ index: Swift.Int, _ value: Swift.Double)
  public func writePosition() -> Swift.Int
  public func requestCapacity(_ capacity: Swift.Int) -> Swift.Bool
  public func getBoolean(_ index: Swift.Int) -> Swift.Bool
  public func get(_ index: Swift.Int) -> Swift.Int8
  public func getShort(_ index: Swift.Int) -> Swift.Int16
  public func getInt(_ index: Swift.Int) -> Swift.Int
  public func getLong(_ index: Swift.Int) -> Swift.Int64
  public func getFloat(_ index: Swift.Int) -> Swift.Float
  public func getDouble(_ index: Swift.Int) -> Swift.Double
  public func getString(_ start: Swift.Int, _ size: Swift.Int) -> Swift.String
  public func data() -> Mocap4Face.KotlinByteArray
  public func limit() -> Swift.Int
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ArrayReadWriteBuf : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.ReadWriteBuf {
  public var _wrappedReadWriteBuf: Swift.AnyObject {
    get
  }
  public var _wrappedReadBuf: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ initialCapacity: Swift.Int = 10)
  convenience public init(_ buffer: Mocap4Face.KotlinByteArray)
  convenience public init(_ buffer: Mocap4Face.KotlinByteArray, _ startPos: Swift.Int)
  public func getBoolean(_ index: Swift.Int) -> Swift.Bool
  public func get(_ index: Swift.Int) -> Swift.Int8
  public func getShort(_ index: Swift.Int) -> Swift.Int16
  public func getInt(_ index: Swift.Int) -> Swift.Int
  public func getLong(_ index: Swift.Int) -> Swift.Int64
  public func getFloat(_ index: Swift.Int) -> Swift.Float
  public func getDouble(_ index: Swift.Int) -> Swift.Double
  public func getString(_ start: Swift.Int, _ size: Swift.Int) -> Swift.String
  public func data() -> Mocap4Face.KotlinByteArray
  public func putBoolean(_ value: Swift.Bool)
  public func put(_ value: Mocap4Face.KotlinByteArray, _ start: Swift.Int, _ length: Swift.Int)
  public func put(_ value: Swift.Int8)
  public func putShort(_ value: Swift.Int16)
  public func putInt(_ value: Swift.Int)
  public func putLong(_ value: Swift.Int64)
  public func putFloat(_ value: Swift.Float)
  public func putDouble(_ value: Swift.Double)
  public func setBoolean(_ index: Swift.Int, _ value: Swift.Bool)
  public func set(_ index: Swift.Int, _ value: Swift.Int8)
  public func set(_ index: Swift.Int, _ value: Mocap4Face.KotlinByteArray, _ start: Swift.Int, _ length: Swift.Int)
  public func setShort(_ index: Swift.Int, _ value: Swift.Int16)
  public func setInt(_ index: Swift.Int, _ value: Swift.Int)
  public func setLong(_ index: Swift.Int, _ value: Swift.Int64)
  public func setFloat(_ index: Swift.Int, _ value: Swift.Float)
  public func setDouble(_ index: Swift.Int, _ value: Swift.Double)
  public func limit() -> Swift.Int
  public func writePosition() -> Swift.Int
  public func requestCapacity(_ capacity: Swift.Int) -> Swift.Bool
  public static func == (lhs: Mocap4Face.ArrayReadWriteBuf, rhs: Mocap4Face.ArrayReadWriteBuf) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class BaseVector : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public var bb: Mocap4Face.ByteBuffer? {
    get
    set(newValue)
  }
  public func __vector() -> Swift.Int
  public func __element(_ j: Swift.Int) -> Swift.Int
  public func __reset(_ _vector: Swift.Int, _ _element_size: Swift.Int, _ _bb: Mocap4Face.ByteBuffer?)
  public func reset()
  public func length() -> Swift.Int
  public static func == (lhs: Mocap4Face.BaseVector, rhs: Mocap4Face.BaseVector) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class BooleanVector : Mocap4Face.BaseVector {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func __assign(_ _vector: Swift.Int, _ _bb: Mocap4Face.ByteBuffer?) -> Mocap4Face.BooleanVector
  public func get(_ j: Swift.Int) -> Swift.Bool
  public static func == (lhs: Mocap4Face.BooleanVector, rhs: Mocap4Face.BooleanVector) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SlicedByteArray : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ array: Mocap4Face.KotlinByteArray, _ start: Swift.Int = 0, _ length: Swift.Int)
  public var size: Swift.Int {
    get
  }
  public var array: Mocap4Face.KotlinByteArray {
    get
  }
  public var start: Swift.Int {
    get
  }
  public func get(_ i: Swift.Int) -> Swift.Int8
  public func set(_ i: Swift.Int, _ value: Swift.Int8) -> Swift.Int8
  public func slice(_ start: Swift.Int) -> Mocap4Face.SlicedByteArray
  public func slicedArray() -> Mocap4Face.KotlinByteArray
  public static func == (lhs: Mocap4Face.SlicedByteArray, rhs: Mocap4Face.SlicedByteArray) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ByteBuffer : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ length: Swift.Int)
  convenience public init(_ array: Mocap4Face.KotlinByteArray, _ start: Swift.Int = 0, _ length: Swift.Int)
  public func get(_ index: Swift.Int) -> Swift.Int8
  public func get() -> Swift.Int8
  public func get(_ dst: Mocap4Face.KotlinByteArray, _ offset: Swift.Int, _ length: Swift.Int) -> Mocap4Face.ByteBuffer
  public func get(_ dst: Mocap4Face.KotlinByteArray) -> Mocap4Face.ByteBuffer
  public func nextFloat() -> Swift.Float
  public func nextShort() -> Swift.Int16
  public func getUByte(_ index: Swift.Int) -> Swift.UInt8
  public func set(_ index: Swift.Int, _ value: Swift.Int8) -> Mocap4Face.ByteBuffer
  public func getShort(_ index: Swift.Int) -> Swift.Int16
  public func getUShort(_ index: Swift.Int) -> Swift.UInt16
  public func getInt(_ index: Swift.Int) -> Swift.Int
  public func getLong(_ index: Swift.Int) -> Swift.Int64
  public func getFloat(_ index: Swift.Int) -> Swift.Float
  public func getDouble(_ index: Swift.Int) -> Swift.Double
  public func putShort(_ index: Swift.Int, _ value: Swift.Int16)
  public func putShort(_ value: Swift.Int16) -> Mocap4Face.ByteBuffer
  public func putInt(_ index: Swift.Int, _ value: Swift.Int)
  public func putInt(_ value: Swift.Int) -> Mocap4Face.ByteBuffer
  public func putLong(_ index: Swift.Int, _ value: Swift.Int64)
  public func putLong(_ value: Swift.Int64) -> Mocap4Face.ByteBuffer
  public func putFloat(_ index: Swift.Int, _ value: Swift.Float)
  public func putFloat(_ value: Swift.Float) -> Mocap4Face.ByteBuffer
  public func putDouble(_ index: Swift.Int, _ value: Swift.Double)
  public func putDouble(_ value: Swift.Double) -> Mocap4Face.ByteBuffer
  public func put(_ index: Swift.Int, _ value: Swift.Int8) -> Mocap4Face.ByteBuffer
  public func put(_ value: Swift.Int8) -> Mocap4Face.ByteBuffer
  public func put(_ index: Swift.Int, _ array: Mocap4Face.KotlinByteArray, _ start: Swift.Int, _ length: Swift.Int) -> Mocap4Face.ByteBuffer
  public func put(_ array: Mocap4Face.KotlinByteArray, _ start: Swift.Int, _ length: Swift.Int) -> Mocap4Face.ByteBuffer
  public func put(_ array: Mocap4Face.KotlinByteArray) -> Mocap4Face.ByteBuffer
  public func put(_ src: Mocap4Face.ByteBuffer)
  public func array() -> Mocap4Face.KotlinByteArray
  public func arrayOffset() -> Swift.Int
  public func position() -> Swift.Int
  public func position(_ newPosition: Swift.Int)
  public func limit() -> Swift.Int
  public func limit(_ newLimit: Swift.Int)
  public func duplicate() -> Mocap4Face.ByteBuffer
  public func slice() -> Mocap4Face.ByteBuffer
  public func clear() -> Mocap4Face.ByteBuffer
  public func hasArray() -> Swift.Bool
  public func capacity() -> Swift.Int
  public func remaining() -> Swift.Int
  public func hasRemaining() -> Swift.Bool
  public func asReadOnlyBuffer() -> Mocap4Face.ByteBuffer
  public func rewind() -> Mocap4Face.ByteBuffer
  public func order(_ o: Mocap4Face.ByteOrder) -> Mocap4Face.ByteBuffer
  public static func allocate(_ capacity: Swift.Int) -> Mocap4Face.ByteBuffer
  public static func wrap(_ buffer: Mocap4Face.KotlinByteArray) -> Mocap4Face.ByteBuffer
  public static func wrap(_ buffer: Mocap4Face.KotlinByteArray, _ start: Swift.Int, _ length: Swift.Int) -> Mocap4Face.ByteBuffer
  public static func == (lhs: Mocap4Face.ByteBuffer, rhs: Mocap4Face.ByteBuffer) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ByteBufferReadWriteBuf : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.ReadWriteBuf {
  public var _wrappedReadWriteBuf: Swift.AnyObject {
    get
  }
  public var _wrappedReadBuf: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ buffer: Mocap4Face.ByteBuffer)
  public func getBoolean(_ index: Swift.Int) -> Swift.Bool
  public func get(_ index: Swift.Int) -> Swift.Int8
  public func getShort(_ index: Swift.Int) -> Swift.Int16
  public func getInt(_ index: Swift.Int) -> Swift.Int
  public func getLong(_ index: Swift.Int) -> Swift.Int64
  public func getFloat(_ index: Swift.Int) -> Swift.Float
  public func getDouble(_ index: Swift.Int) -> Swift.Double
  public func getString(_ start: Swift.Int, _ size: Swift.Int) -> Swift.String
  public func data() -> Mocap4Face.KotlinByteArray
  public func putBoolean(_ value: Swift.Bool)
  public func put(_ value: Mocap4Face.KotlinByteArray, _ start: Swift.Int, _ length: Swift.Int)
  public func put(_ value: Swift.Int8)
  public func putShort(_ value: Swift.Int16)
  public func putInt(_ value: Swift.Int)
  public func putLong(_ value: Swift.Int64)
  public func putFloat(_ value: Swift.Float)
  public func putDouble(_ value: Swift.Double)
  public func setBoolean(_ index: Swift.Int, _ value: Swift.Bool)
  public func set(_ index: Swift.Int, _ value: Swift.Int8)
  public func set(_ index: Swift.Int, _ value: Mocap4Face.KotlinByteArray, _ start: Swift.Int, _ length: Swift.Int)
  public func setShort(_ index: Swift.Int, _ value: Swift.Int16)
  public func setInt(_ index: Swift.Int, _ value: Swift.Int)
  public func setLong(_ index: Swift.Int, _ value: Swift.Int64)
  public func setFloat(_ index: Swift.Int, _ value: Swift.Float)
  public func setDouble(_ index: Swift.Int, _ value: Swift.Double)
  public func writePosition() -> Swift.Int
  public func limit() -> Swift.Int
  public func requestCapacity(_ capacity: Swift.Int) -> Swift.Bool
  public static func == (lhs: Mocap4Face.ByteBufferReadWriteBuf, rhs: Mocap4Face.ByteBufferReadWriteBuf) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ByteBufferUtilClass : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func getSizePrefix(_ bb: Mocap4Face.ByteBuffer) -> Swift.Int
  public func removeSizePrefix(_ bb: Mocap4Face.ByteBuffer) -> Mocap4Face.ByteBuffer
  public static func == (lhs: Mocap4Face.ByteBufferUtilClass, rhs: Mocap4Face.ByteBufferUtilClass) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public let ByteBufferUtil: Mocap4Face.ByteBufferUtilClass
public enum ByteOrder : Swift.CustomStringConvertible, Mocap4Face.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case littleEndian
  case bigEndian
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: Mocap4Face.ByteOrder, b: Mocap4Face.ByteOrder) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ByteVector : Mocap4Face.BaseVector {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func __assign(_ vector: Swift.Int, _ bb: Mocap4Face.ByteBuffer?) -> Mocap4Face.ByteVector
  public func get(_ j: Swift.Int) -> Swift.Int8
  public func getAsUnsigned(_ j: Swift.Int) -> Swift.Int
  public static func == (lhs: Mocap4Face.ByteVector, rhs: Mocap4Face.ByteVector) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ConstantsClass : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var SIZEOF_BYTE: Swift.Int {
    get
  }
  public var SIZEOF_SHORT: Swift.Int {
    get
  }
  public var SIZEOF_INT: Swift.Int {
    get
  }
  public var SIZEOF_FLOAT: Swift.Int {
    get
  }
  public var SIZEOF_LONG: Swift.Int {
    get
  }
  public var SIZEOF_DOUBLE: Swift.Int {
    get
  }
  public var FILE_IDENTIFIER_LENGTH: Swift.Int {
    get
  }
  public var SIZE_PREFIX_LENGTH: Swift.Int {
    get
  }
  public func FLATBUFFERS_1_12_0()
  public static func == (lhs: Mocap4Face.ConstantsClass, rhs: Mocap4Face.ConstantsClass) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public let Constants: Mocap4Face.ConstantsClass
@_hasMissingDesignatedInitializers public class DoubleVector : Mocap4Face.BaseVector {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func __assign(_ _vector: Swift.Int, _ _bb: Mocap4Face.ByteBuffer?) -> Mocap4Face.DoubleVector
  public func get(_ j: Swift.Int) -> Swift.Double
  public static func == (lhs: Mocap4Face.DoubleVector, rhs: Mocap4Face.DoubleVector) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FlatBufferBuilder : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ existing_bb: Mocap4Face.ByteBuffer, _ bb_factory: Mocap4Face.FlatBufferBuilder.ByteBufferFactory = HeapByteBufferFactory())
  convenience public init(_ initial_size: Swift.Int = 1024, _ bb_factory: Mocap4Face.FlatBufferBuilder.ByteBufferFactory = HeapByteBufferFactory.INSTANCE, _ existing_bb: Mocap4Face.ByteBuffer? = nil, _ utf8: Mocap4Face.Utf8 = Utf8.default_)
  public var bb: Mocap4Face.ByteBuffer? {
    get
    set(newValue)
  }
  public var space: Swift.Int {
    get
    set(newValue)
  }
  public var minalign: Swift.Int {
    get
    set(newValue)
  }
  public var vtable: Mocap4Face.KotlinIntArray? {
    get
    set(newValue)
  }
  public var vtable_in_use: Swift.Int {
    get
    set(newValue)
  }
  public var nested: Swift.Bool {
    get
    set(newValue)
  }
  public var object_start: Swift.Int {
    get
    set(newValue)
  }
  public var vtables: Mocap4Face.KotlinIntArray {
    get
    set(newValue)
  }
  public var num_vtables: Swift.Int {
    get
    set(newValue)
  }
  public var vector_num_elems: Swift.Int {
    get
    set(newValue)
  }
  public var force_defaults: Swift.Bool {
    get
    set(newValue)
  }
  public var bb_factory: Mocap4Face.FlatBufferBuilder.ByteBufferFactory {
    get
    set(newValue)
  }
  public var utf8: Mocap4Face.Utf8 {
    get
  }
  public func doInit(_ existing_bb: Mocap4Face.ByteBuffer?, _ bb_factory: Mocap4Face.FlatBufferBuilder.ByteBufferFactory) -> Mocap4Face.FlatBufferBuilder
  public func clear()
  public func offset() -> Swift.Int
  public func pad(_ byte_size: Swift.Int)
  public func prep(_ size: Swift.Int, _ additional_bytes: Swift.Int)
  public func putBoolean(_ x: Swift.Bool)
  public func putByte(_ x: Swift.Int8)
  public func putShort(_ x: Swift.Int16)
  public func putInt(_ x: Swift.Int)
  public func putLong(_ x: Swift.Int64)
  public func putFloat(_ x: Swift.Float)
  public func putDouble(_ x: Swift.Double)
  public func addBoolean(_ x: Swift.Bool)
  public func addBoolean(_ o: Swift.Int, _ x: Swift.Bool, _ d: Swift.Bool)
  public func addByte(_ x: Swift.Int8)
  public func addByte(_ o: Swift.Int, _ x: Swift.Int8, _ d: Swift.Int)
  public func addShort(_ x: Swift.Int16)
  public func addShort(_ o: Swift.Int, _ x: Swift.Int16, _ d: Swift.Int)
  public func addInt(_ x: Swift.Int)
  public func addInt(_ o: Swift.Int, _ x: Swift.Int, _ d: Swift.Int)
  public func addLong(_ x: Swift.Int64)
  public func addLong(_ o: Swift.Int, _ x: Swift.Int64, _ d: Swift.Int64)
  public func addFloat(_ x: Swift.Float)
  public func addFloat(_ o: Swift.Int, _ x: Swift.Float, _ d: Swift.Double)
  public func addDouble(_ x: Swift.Double)
  public func addDouble(_ o: Swift.Int, _ x: Swift.Double, _ d: Swift.Double)
  public func addOffset(_ off: Swift.Int)
  public func addOffset(_ o: Swift.Int, _ x: Swift.Int, _ d: Swift.Int)
  public func startVector(_ elem_size: Swift.Int, _ num_elems: Swift.Int, _ alignment: Swift.Int)
  public func endVector() -> Swift.Int
  public func createUnintializedVector(_ elem_size: Swift.Int, _ num_elems: Swift.Int, _ alignment: Swift.Int) -> Mocap4Face.ByteBuffer
  public func createVectorOfTables(_ offsets: Mocap4Face.KotlinIntArray) -> Swift.Int
  public func createSortedVectorOfTables<T>(_ obj: T, _ offsets: Mocap4Face.KotlinIntArray) -> Swift.Int where T : Mocap4Face.Table
  public func createString(_ s: Any) -> Swift.Int
  public func createString(_ s_: Mocap4Face.ByteBuffer) -> Swift.Int
  public func createByteVector(_ arr: Mocap4Face.KotlinByteArray) -> Swift.Int
  public func createByteVector(_ arr: Mocap4Face.KotlinByteArray, _ offset: Swift.Int, _ length: Swift.Int) -> Swift.Int
  public func createByteVector(_ byteBuffer: Mocap4Face.ByteBuffer) -> Swift.Int
  public func finished()
  public func notNested()
  public func Nested(_ obj: Swift.Int)
  public func startTable(_ numfields: Swift.Int)
  public func addStruct(_ voffset: Swift.Int, _ x: Swift.Int, _ d: Swift.Int)
  public func slot(_ voffset: Swift.Int)
  public func endTable() -> Swift.Int
  public func required(_ table: Swift.Int, _ field: Swift.Int)
  public func finish(_ root_table: Swift.Int, _ size_prefix: Swift.Bool)
  public func finish(_ root_table: Swift.Int)
  public func finish(_ root_table: Swift.Int, _ file_identifier: Swift.String, _ size_prefix: Swift.Bool)
  public func finish(_ root_table: Swift.Int, _ file_identifier: Swift.String)
  public func finishSizePrefixed(_ root_table: Swift.Int)
  public func finishSizePrefixed(_ root_table: Swift.Int, _ file_identifier: Swift.String)
  public func forceDefaults(_ forceDefaults: Swift.Bool) -> Mocap4Face.FlatBufferBuilder
  public func dataBuffer() -> Mocap4Face.ByteBuffer?
  public func sizedByteArray(_ start: Swift.Int, _ length: Swift.Int) -> Mocap4Face.KotlinByteArray
  public static func isFieldPresent(_ table: Mocap4Face.Table, _ offset: Swift.Int) -> Swift.Bool
  public static func growByteBuffer(_ bb: Mocap4Face.ByteBuffer, _ bb_factory: Mocap4Face.FlatBufferBuilder.ByteBufferFactory) -> Mocap4Face.ByteBuffer
  public static func == (lhs: Mocap4Face.FlatBufferBuilder, rhs: Mocap4Face.FlatBufferBuilder) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension FlatBufferBuilder {
  @_hasMissingDesignatedInitializers public class ByteBufferFactory : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    public func asKotlin() -> Swift.AnyObject
    convenience public init()
    public func doNewByteBuffer(_ capacity: Swift.Int) -> Mocap4Face.ByteBuffer
    public func releaseByteBuffer(_ bb: Mocap4Face.ByteBuffer?)
    public static func == (lhs: Mocap4Face.FlatBufferBuilder.ByteBufferFactory, rhs: Mocap4Face.FlatBufferBuilder.ByteBufferFactory) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension FlatBufferBuilder {
  @_hasMissingDesignatedInitializers public class HeapByteBufferFactory : Mocap4Face.FlatBufferBuilder.ByteBufferFactory {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init()
    public static var INSTANCE: Mocap4Face.FlatBufferBuilder.HeapByteBufferFactory {
      get
    }
    public static func == (lhs: Mocap4Face.FlatBufferBuilder.HeapByteBufferFactory, rhs: Mocap4Face.FlatBufferBuilder.HeapByteBufferFactory) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers public class FlexBuffersClass : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var FBT_NULL: Swift.Int {
    get
  }
  public var FBT_INT: Swift.Int {
    get
  }
  public var FBT_UINT: Swift.Int {
    get
  }
  public var FBT_FLOAT: Swift.Int {
    get
  }
  public var FBT_KEY: Swift.Int {
    get
  }
  public var FBT_STRING: Swift.Int {
    get
  }
  public var FBT_INDIRECT_INT: Swift.Int {
    get
  }
  public var FBT_INDIRECT_UINT: Swift.Int {
    get
  }
  public var FBT_INDIRECT_FLOAT: Swift.Int {
    get
  }
  public var FBT_MAP: Swift.Int {
    get
  }
  public var FBT_VECTOR: Swift.Int {
    get
  }
  public var FBT_VECTOR_INT: Swift.Int {
    get
  }
  public var FBT_VECTOR_UINT: Swift.Int {
    get
  }
  public var FBT_VECTOR_FLOAT: Swift.Int {
    get
  }
  public var FBT_VECTOR_KEY: Swift.Int {
    get
  }
  public var FBT_VECTOR_STRING_DEPRECATED: Swift.Int {
    get
  }
  public var FBT_VECTOR_INT2: Swift.Int {
    get
  }
  public var FBT_VECTOR_UINT2: Swift.Int {
    get
  }
  public var FBT_VECTOR_FLOAT2: Swift.Int {
    get
  }
  public var FBT_VECTOR_INT3: Swift.Int {
    get
  }
  public var FBT_VECTOR_UINT3: Swift.Int {
    get
  }
  public var FBT_VECTOR_FLOAT3: Swift.Int {
    get
  }
  public var FBT_VECTOR_INT4: Swift.Int {
    get
  }
  public var FBT_VECTOR_UINT4: Swift.Int {
    get
  }
  public var FBT_VECTOR_FLOAT4: Swift.Int {
    get
  }
  public var FBT_BLOB: Swift.Int {
    get
  }
  public var FBT_BOOL: Swift.Int {
    get
  }
  public var FBT_VECTOR_BOOL: Swift.Int {
    get
  }
  public func isTypedVector(_ type: Swift.Int) -> Swift.Bool
  public func isTypeInline(_ type: Swift.Int) -> Swift.Bool
  public func toTypedVectorElementType(_ original_type: Swift.Int) -> Swift.Int
  public func toTypedVector(_ type: Swift.Int, _ fixedLength: Swift.Int) -> Swift.Int
  public func isTypedVectorElementType(_ type: Swift.Int) -> Swift.Bool
  @available(*, deprecated, message: "Deprecated")
  public func getRoot(_ buffer: Mocap4Face.ByteBuffer) -> Mocap4Face.FlexBuffersClass.Reference
  public func getRoot(_ buffer_: Mocap4Face.ReadBuf) -> Mocap4Face.FlexBuffersClass.Reference
  public static func == (lhs: Mocap4Face.FlexBuffersClass, rhs: Mocap4Face.FlexBuffersClass) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public let FlexBuffers: Mocap4Face.FlexBuffersClass
extension FlexBuffersClass {
  @_hasMissingDesignatedInitializers public class Reference : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    public func asKotlin() -> Swift.AnyObject
    public var isNull: Swift.Bool {
      get
    }
    public var isBoolean: Swift.Bool {
      get
    }
    public var isNumeric: Swift.Bool {
      get
    }
    public var isIntOrUInt: Swift.Bool {
      get
    }
    public var isFloat: Swift.Bool {
      get
    }
    public var isInt: Swift.Bool {
      get
    }
    public var isUInt: Swift.Bool {
      get
    }
    public var isString: Swift.Bool {
      get
    }
    public var isKey: Swift.Bool {
      get
    }
    public var isVector: Swift.Bool {
      get
    }
    public var isTypedVector: Swift.Bool {
      get
    }
    public var isMap: Swift.Bool {
      get
    }
    public var isBlob: Swift.Bool {
      get
    }
    public var type: Swift.Int {
      get
    }
    public static var NULL_REFERENCE: Mocap4Face.FlexBuffersClass.Reference {
      get
    }
    public func asInt() -> Swift.Int
    public func asUInt() -> Swift.Int64
    public func asLong() -> Swift.Int64
    public func asFloat() -> Swift.Double
    public func asKey() -> Mocap4Face.FlexBuffersClass.Key
    public func asString() -> Swift.String?
    public func asMap() -> Mocap4Face.FlexBuffersClass.Map
    public func asVector() -> Mocap4Face.FlexBuffersClass.Vector
    public func asBlob() -> Mocap4Face.FlexBuffersClass.Blob
    public func asBoolean() -> Swift.Bool
    public func description() -> Swift.String
    public func toString(_ sb: Mocap4Face.KotlinStringBuilder) -> Mocap4Face.KotlinStringBuilder
    public static func == (lhs: Mocap4Face.FlexBuffersClass.Reference, rhs: Mocap4Face.FlexBuffersClass.Reference) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension FlexBuffersClass {
  @_hasMissingDesignatedInitializers public class Object : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    public func asKotlin() -> Swift.AnyObject
    public var bb: Mocap4Face.ReadBuf {
      get
      set(newValue)
    }
    public var end: Swift.Int {
      get
      set(newValue)
    }
    public var byteWidth: Swift.Int {
      get
      set(newValue)
    }
    public func description() -> Swift.String
    public func toString(_ sb: Mocap4Face.KotlinStringBuilder) -> Mocap4Face.KotlinStringBuilder
    public static func == (lhs: Mocap4Face.FlexBuffersClass.Object, rhs: Mocap4Face.FlexBuffersClass.Object) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension FlexBuffersClass {
  @_hasMissingDesignatedInitializers public class Sized : Mocap4Face.FlexBuffersClass.Object {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    public func size() -> Swift.Int
    public static func == (lhs: Mocap4Face.FlexBuffersClass.Sized, rhs: Mocap4Face.FlexBuffersClass.Sized) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension FlexBuffersClass {
  @_hasMissingDesignatedInitializers public class Blob : Mocap4Face.FlexBuffersClass.Sized {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    public var bytes: Mocap4Face.KotlinByteArray {
      get
    }
    public static var EMPTY: Mocap4Face.FlexBuffersClass.Blob {
      get
    }
    public func data() -> Mocap4Face.ByteBuffer
    public func get(_ pos: Swift.Int) -> Swift.Int8
    public static func empty() -> Mocap4Face.FlexBuffersClass.Blob
    public static func == (lhs: Mocap4Face.FlexBuffersClass.Blob, rhs: Mocap4Face.FlexBuffersClass.Blob) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension FlexBuffersClass {
  @_hasMissingDesignatedInitializers public class Key : Mocap4Face.FlexBuffersClass.Object {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    public static var EMPTY: Mocap4Face.FlexBuffersClass.Key {
      get
    }
    public func compareTo(_ other: Mocap4Face.KotlinByteArray) -> Swift.Int
    public func isEqual(_ other: Any?) -> Swift.Bool
    public func hash() -> Swift.UInt
    public static func empty() -> Mocap4Face.FlexBuffersClass.Key
    public static func == (lhs: Mocap4Face.FlexBuffersClass.Key, rhs: Mocap4Face.FlexBuffersClass.Key) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension FlexBuffersClass {
  @_hasMissingDesignatedInitializers public class Vector : Mocap4Face.FlexBuffersClass.Sized {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    public var isEmpty: Swift.Bool {
      get
    }
    public func get(_ index_: Swift.Int) -> Mocap4Face.FlexBuffersClass.Reference
    public static func empty() -> Mocap4Face.FlexBuffersClass.Vector
    public static func == (lhs: Mocap4Face.FlexBuffersClass.Vector, rhs: Mocap4Face.FlexBuffersClass.Vector) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension FlexBuffersClass {
  @_hasMissingDesignatedInitializers public class Map : Mocap4Face.FlexBuffersClass.Vector {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    public func get(_ key: Swift.String) -> Mocap4Face.FlexBuffersClass.Reference
    public func get(_ key_: Mocap4Face.KotlinByteArray) -> Mocap4Face.FlexBuffersClass.Reference
    public func keys() -> Mocap4Face.FlexBuffersClass.KeyVector
    public func values() -> Mocap4Face.FlexBuffersClass.Vector
    public static func == (lhs: Mocap4Face.FlexBuffersClass.Map, rhs: Mocap4Face.FlexBuffersClass.Map) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension FlexBuffersClass {
  @_hasMissingDesignatedInitializers public class TypedVector : Mocap4Face.FlexBuffersClass.Vector {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    public var isEmptyVector: Swift.Bool {
      get
    }
    public var elemType: Swift.Int {
      get
    }
    public static func == (lhs: Mocap4Face.FlexBuffersClass.TypedVector, rhs: Mocap4Face.FlexBuffersClass.TypedVector) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension FlexBuffersClass {
  @_hasMissingDesignatedInitializers public class KeyVector : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    public func asKotlin() -> Swift.AnyObject
    public func get(_ pos: Swift.Int) -> Mocap4Face.FlexBuffersClass.Key
    public func size() -> Swift.Int
    public func description() -> Swift.String
    public static func == (lhs: Mocap4Face.FlexBuffersClass.KeyVector, rhs: Mocap4Face.FlexBuffersClass.KeyVector) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
    public var hashValue: Swift.Int {
      get
    }
  }
}
@_hasMissingDesignatedInitializers public class KotlinThrowable : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ message: Swift.String?)
  convenience public init(_ cause: Mocap4Face.KotlinThrowable?)
  convenience public init()
  convenience public init(_ message: Swift.String?, _ cause: Mocap4Face.KotlinThrowable?)
  public var cause: Mocap4Face.KotlinThrowable? {
    get
  }
  public var message: Swift.String? {
    get
  }
  public func getStackTrace() -> Mocap4Face.KotlinArray<Swift.String>
  public func printStackTrace()
  public func description() -> Swift.String
  public static func == (lhs: Mocap4Face.KotlinThrowable, rhs: Mocap4Face.KotlinThrowable) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinException : Mocap4Face.KotlinThrowable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init()
  convenience public init(_ message: Swift.String?)
  convenience public init(_ message: Swift.String?, _ cause: Mocap4Face.KotlinThrowable?)
  convenience public init(_ cause: Mocap4Face.KotlinThrowable?)
  public static func == (lhs: Mocap4Face.KotlinException, rhs: Mocap4Face.KotlinException) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KotlinRuntimeException : Mocap4Face.KotlinException {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init()
  convenience public init(_ message: Swift.String?)
  convenience public init(_ message: Swift.String?, _ cause: Mocap4Face.KotlinThrowable?)
  convenience public init(_ cause: Mocap4Face.KotlinThrowable?)
  public static func == (lhs: Mocap4Face.KotlinRuntimeException, rhs: Mocap4Face.KotlinRuntimeException) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
extension FlexBuffersClass {
  @_hasMissingDesignatedInitializers public class FlexBufferException : Mocap4Face.KotlinRuntimeException {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    public static func == (lhs: Mocap4Face.FlexBuffersClass.FlexBufferException, rhs: Mocap4Face.FlexBuffersClass.FlexBufferException) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers public class FlexBuffersBuilder : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ bufSize: Swift.Int = 256)
  @available(*, deprecated, message: "Deprecated")
  convenience public init(_ bb: Mocap4Face.ByteBuffer, _ flags: Swift.Int)
  convenience public init(_ bb: Mocap4Face.ByteBuffer)
  convenience public init(_ bb: Mocap4Face.ReadWriteBuf, _ flags_: Swift.Int)
  public var buffer: Mocap4Face.ReadWriteBuf {
    get
  }
  public static var BUILDER_FLAG_NONE: Swift.Int {
    get
  }
  public static var BUILDER_FLAG_SHARE_KEYS: Swift.Int {
    get
  }
  public static var BUILDER_FLAG_SHARE_STRINGS: Swift.Int {
    get
  }
  public static var BUILDER_FLAG_SHARE_KEYS_AND_STRINGS: Swift.Int {
    get
  }
  public static var BUILDER_FLAG_SHARE_KEY_VECTORS: Swift.Int {
    get
  }
  public static var BUILDER_FLAG_SHARE_ALL: Swift.Int {
    get
  }
  public func putBoolean(_ val: Swift.Bool)
  public func putBoolean(_ key: Swift.String?, _ val: Swift.Bool)
  public func putInt(_ val: Swift.Int)
  public func putInt(_ key: Swift.String?, _ val: Swift.Int)
  public func putInt(_ key: Swift.String?, _ val_: Swift.Int64)
  public func putInt(_ value: Swift.Int64)
  public func putUInt(_ value: Swift.Int)
  public func putUInt(_ value_: Swift.Int64)
  public func putFloat(_ value: Swift.Float)
  public func putFloat(_ key: Swift.String?, _ val: Swift.Float)
  public func putFloat(_ value_: Swift.Double)
  public func putFloat(_ key: Swift.String?, _ val_: Swift.Double)
  public func putString(_ value: Swift.String) -> Swift.Int
  public func putString(_ key: Swift.String?, _ val: Swift.String) -> Swift.Int
  public func putBlob(_ value: Mocap4Face.KotlinByteArray) -> Swift.Int
  public func putBlob(_ key: Swift.String?, _ val: Mocap4Face.KotlinByteArray) -> Swift.Int
  public func startVector() -> Swift.Int
  public func endVector(_ key: Swift.String?, _ start: Swift.Int, _ typed: Swift.Bool, _ fixed: Swift.Bool) -> Swift.Int
  public func finish() -> Mocap4Face.ByteBuffer
  public func startMap() -> Swift.Int
  public func endMap(_ key: Swift.String?, _ start: Swift.Int) -> Swift.Int
  public static func widthUInBits(_ len: Swift.Int64) -> Swift.Int
  public static func == (lhs: Mocap4Face.FlexBuffersBuilder, rhs: Mocap4Face.FlexBuffersBuilder) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FloatVector : Mocap4Face.BaseVector {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func __assign(_ _vector: Swift.Int, _ _bb: Mocap4Face.ByteBuffer?) -> Mocap4Face.FloatVector
  public func get(_ j: Swift.Int) -> Swift.Float
  public static func == (lhs: Mocap4Face.FloatVector, rhs: Mocap4Face.FloatVector) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class IntVector : Mocap4Face.BaseVector {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func __assign(_ _vector: Swift.Int, _ _bb: Mocap4Face.ByteBuffer?) -> Mocap4Face.IntVector
  public func get(_ j: Swift.Int) -> Swift.Int
  public func getAsUnsigned(_ j: Swift.Int) -> Swift.Int64
  public static func == (lhs: Mocap4Face.IntVector, rhs: Mocap4Face.IntVector) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class LongVector : Mocap4Face.BaseVector {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func __assign(_ _vector: Swift.Int, _ _bb: Mocap4Face.ByteBuffer?) -> Mocap4Face.LongVector
  public func get(_ j: Swift.Int) -> Swift.Int64
  public static func == (lhs: Mocap4Face.LongVector, rhs: Mocap4Face.LongVector) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ShortVector : Mocap4Face.BaseVector {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func __assign(_ _vector: Swift.Int, _ _bb: Mocap4Face.ByteBuffer?) -> Mocap4Face.ShortVector
  public func get(_ j: Swift.Int) -> Swift.Int16
  public func getAsUnsigned(_ j: Swift.Int) -> Swift.Int
  public static func == (lhs: Mocap4Face.ShortVector, rhs: Mocap4Face.ShortVector) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class StringVector : Mocap4Face.BaseVector {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func __assign(_ _vector: Swift.Int, _ _element_size: Swift.Int, _ _bb: Mocap4Face.ByteBuffer?) -> Mocap4Face.StringVector
  public func get(_ j: Swift.Int) -> Swift.String
  public static func == (lhs: Mocap4Face.StringVector, rhs: Mocap4Face.StringVector) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Struct : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public var bb_pos: Swift.Int {
    get
    set(newValue)
  }
  public var bb: Mocap4Face.ByteBuffer? {
    get
    set(newValue)
  }
  public func __reset(_ _i: Swift.Int, _ _bb: Mocap4Face.ByteBuffer?)
  public func __reset()
  public static func == (lhs: Mocap4Face.Struct, rhs: Mocap4Face.Struct) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Table : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public var bb_pos: Swift.Int {
    get
    set(newValue)
  }
  public var byteBuffer: Mocap4Face.ByteBuffer? {
    get
    set(newValue)
  }
  public var utf8: Mocap4Face.Utf8 {
    get
    set(newValue)
  }
  public var bb: Mocap4Face.ByteBuffer {
    get
  }
  public func __offset(_ vtable_offset: Swift.Int) -> Swift.Int
  public func __indirect(_ offset: Swift.Int) -> Swift.Int
  public func __string(_ offset: Swift.Int) -> Swift.String
  public func __vector_len(_ offset: Swift.Int) -> Swift.Int
  public func __vector(_ offset: Swift.Int) -> Swift.Int
  public func __vector_as_bytebuffer(_ vector_offset: Swift.Int, _ elem_size: Swift.Int) -> Mocap4Face.ByteBuffer
  public func __vector_in_bytebuffer(_ bb: Mocap4Face.ByteBuffer, _ vector_offset: Swift.Int, _ elem_size: Swift.Int) -> Mocap4Face.ByteBuffer
  public func __union(_ t: Mocap4Face.Table?, _ offset: Swift.Int) -> Mocap4Face.Table
  public func sortTables(_ offsets: Mocap4Face.KotlinIntArray, _ bb: Mocap4Face.ByteBuffer?)
  public func keysCompare(_ o1: Swift.Int?, _ o2: Swift.Int?, _ bb: Mocap4Face.ByteBuffer?) -> Swift.Int
  public func __reset(_ _i: Swift.Int, _ _bb: Mocap4Face.ByteBuffer?)
  public func __reset()
  public static func __offset(_ vtable_offset: Swift.Int, _ offset: Swift.Int, _ bb: Mocap4Face.ByteBuffer) -> Swift.Int
  public static func __indirect(_ offset: Swift.Int, _ bb: Mocap4Face.ByteBuffer) -> Swift.Int
  public static func __string(_ offset: Swift.Int, _ bb: Mocap4Face.ByteBuffer, _ utf8: Mocap4Face.Utf8) -> Swift.String
  public static func __union(_ t: Mocap4Face.Table, _ offset: Swift.Int, _ bb: Mocap4Face.ByteBuffer?) -> Mocap4Face.Table
  public static func __has_identifier(_ bb: Mocap4Face.ByteBuffer, _ ident: Swift.String) -> Swift.Bool
  public static func compareStrings(_ offset_1: Swift.Int, _ offset_2: Swift.Int, _ bb: Mocap4Face.ByteBuffer) -> Swift.Int
  public static func compareStrings(_ offset_1: Swift.Int, _ key: Mocap4Face.KotlinByteArray, _ bb: Mocap4Face.ByteBuffer) -> Swift.Int
  public static func == (lhs: Mocap4Face.Table, rhs: Mocap4Face.Table) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class UnionVector : Mocap4Face.BaseVector {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func __assign(_ _vector: Swift.Int, _ _element_size: Swift.Int, _ _bb: Mocap4Face.ByteBuffer?) -> Mocap4Face.UnionVector
  public func get(_ obj: Mocap4Face.Table?, _ j: Swift.Int) -> Mocap4Face.Table
  public static func == (lhs: Mocap4Face.UnionVector, rhs: Mocap4Face.UnionVector) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Utf8 : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public static var default_: Mocap4Face.Utf8 {
    get
    set(newValue)
  }
  public func encodedLength(_ sequence: Any) -> Swift.Int
  public func encodeUtf8(_ in: Any, _ out: Mocap4Face.ByteBuffer)
  public func decodeUtf8(_ buffer: Mocap4Face.ByteBuffer, _ offset: Swift.Int, _ length: Swift.Int) -> Swift.String
  public static func == (lhs: Mocap4Face.Utf8, rhs: Mocap4Face.Utf8) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Utf8Safe : Mocap4Face.Utf8 {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public static func decodeUtf8Array(_ bytes: Mocap4Face.KotlinByteArray, _ index: Swift.Int, _ size: Swift.Int) -> Swift.String
  public static func decodeUtf8Buffer(_ buffer: Mocap4Face.ByteBuffer, _ offset: Swift.Int, _ length: Swift.Int) -> Swift.String
  public static func == (lhs: Mocap4Face.Utf8Safe, rhs: Mocap4Face.Utf8Safe) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
public protocol Animator {
  associatedtype T
  var _wrappedAnimator: Swift.AnyObject { get }
  func frame(_ time: Swift.Float) -> Self.T
  func finished(_ time: Swift.Float) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class AnimatorWrapper<T> : Mocap4Face.ConvertibleToKotlin, Mocap4Face.Animator {
  public typealias T = T
  public var _wrappedAnimator: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func frame(_ time: Swift.Float) -> T
  public func finished(_ time: Swift.Float) -> Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers public class AnimatorKey<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ time: Swift.Float, _ value: T)
  public var time: Swift.Float {
    get
  }
  public var value: T {
    get
  }
  public static func == (lhs: Mocap4Face.AnimatorKey<T>, rhs: Mocap4Face.AnimatorKey<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class SimpleAnimator<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.Animator where T : Mocap4Face.Vec {
  public typealias T = T
  public var _wrappedAnimator: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ keyFrames: Any, _ transition: @escaping (Swift.Float) -> Swift.Float = linearTransition)
  public var transition: (Swift.Float) -> Swift.Float {
    get
  }
  public func frame(_ time: Swift.Float) -> T
  public func finished(_ time: Swift.Float) -> Swift.Bool
  public static func == (lhs: Mocap4Face.SimpleAnimator<T>, rhs: Mocap4Face.SimpleAnimator<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ConfigurableAnimator<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.Animator {
  public typealias T = T
  public var _wrappedAnimator: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ keyFrames: Any, _ numberOfRuns: Swift.Int, _ interpolator: @escaping (Swift.Float, T, T, Mocap4Face.AnimatorKey<T>?, Mocap4Face.AnimatorKey<T>?) -> T)
  public func frame(_ time: Swift.Float) -> T
  public func finished(_ time: Swift.Float) -> Swift.Bool
  public static func == (lhs: Mocap4Face.ConfigurableAnimator<T>, rhs: Mocap4Face.ConfigurableAnimator<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Camera : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var viewMatrix: Mocap4Face.Mat4 {
    get
  }
  public var eye: Mocap4Face.Vec3 {
    get
  }
  public var origin: Mocap4Face.Vec3 {
    get
  }
  public var view: Mocap4Face.Vec3 {
    get
  }
  public var orbit: Swift.Bool {
    get
  }
  public var orbitRadius: Swift.Float {
    get
  }
  public func orthoNormalized() -> Mocap4Face.Camera
  public func forward(_ speed: Swift.Float = 1.n) -> Mocap4Face.Camera
  public func backward(_ speed: Swift.Float = 1.n) -> Mocap4Face.Camera
  public func right(_ speed: Swift.Float = 1.n) -> Mocap4Face.Camera
  public func left(_ speed: Swift.Float = 1.n) -> Mocap4Face.Camera
  public func up(_ speed: Swift.Float = 1.n, _ upOverride: Mocap4Face.Vec3? = nil) -> Mocap4Face.Camera
  public func down(_ speed: Swift.Float = 1.n, _ upOverride: Mocap4Face.Vec3? = nil) -> Mocap4Face.Camera
  public func lookTo(_ viewDirection: Mocap4Face.Vec3, _ verticalUp: Mocap4Face.Vec3? = nil) -> Mocap4Face.Camera
  public func lookAt(_ target: Mocap4Face.Vec3, _ verticalUp: Mocap4Face.Vec3? = nil) -> Mocap4Face.Camera
  public func rotate(_ azimuth: Swift.Float, _ zenith: Swift.Float, _ verticalUp: Mocap4Face.Vec3 = Vec3.zAxis, _ zenithLimit: Swift.Float? = 0.01.n) -> Mocap4Face.Camera
  public func rotate(_ heading: Swift.Float, _ elevation: Swift.Float, _ bank: Swift.Float) -> Mocap4Face.Camera
  public func withOrigin(_ origin: Mocap4Face.Vec3) -> Mocap4Face.Camera
  public func withView(_ view: Mocap4Face.Vec3) -> Mocap4Face.Camera
  public func withUp(_ up: Mocap4Face.Vec3) -> Mocap4Face.Camera
  public func withOrbit(_ orbit: Swift.Bool) -> Mocap4Face.Camera
  public func withOrbitRadius(_ orbitRadius: Swift.Float) -> Mocap4Face.Camera
  public static func lookTo(_ origin: Mocap4Face.Vec3, _ viewDirection: Mocap4Face.Vec3, _ upDirection: Mocap4Face.Vec3, _ orbit: Swift.Bool = false, _ orbitRadius: Swift.Float) -> Mocap4Face.Camera
  public static func lookAt(_ lookFrom: Mocap4Face.Vec3, _ lookAt: Mocap4Face.Vec3, _ upDirection: Mocap4Face.Vec3, _ orbit: Swift.Bool = false) -> Mocap4Face.Camera
  public static func == (lhs: Mocap4Face.Camera, rhs: Mocap4Face.Camera) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class OrbitCameraControls : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var camera: Mocap4Face.Camera {
    get
  }
  public func tick(_ delta: Swift.Float) -> Mocap4Face.OrbitCameraControls
  public static func from(_ basePosition: Mocap4Face.Vec3, _ targetPosition: Mocap4Face.Vec3, _ timeToRotate: Swift.Float, _ rotationalAxis: Mocap4Face.Vec3 = Vec3.zAxis) -> Mocap4Face.OrbitCameraControls
  public static func == (lhs: Mocap4Face.OrbitCameraControls, rhs: Mocap4Face.OrbitCameraControls) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Vec {
  typealias T = Self
  var _wrappedVec: Swift.AnyObject { get }
  func plus(_ rhs: Self.T) -> Self
  func plus(_ rhs_: Swift.Double) -> Self
  func plus(_ rhs__: Swift.Float) -> Self
  func minus(_ rhs: Self.T) -> Self
  func minus(_ rhs_: Swift.Double) -> Self
  func minus(_ rhs__: Swift.Float) -> Self
  func times(_ rhs: Swift.Double) -> Self
  func times(_ rhs_: Swift.Float) -> Self
  func times(_ rhs__: Self.T) -> Self
  func div(_ rhs: Swift.Double) -> Self
  func div(_ rhs_: Swift.Float) -> Self
  func div(_ rhs__: Self.T) -> Self
  func unaryMinus() -> Self
  func invDiv(_ rhs: Swift.Double) -> Self
  func invDiv(_ rhs_: Swift.Float) -> Self
  func sum() -> Swift.Float
  func length_() -> Swift.Float
  func min() -> Swift.Float
  func max() -> Swift.Float
  func dot(_ rhs: Self.T) -> Swift.Float
  func normalized() -> Self?
  func normalized(_ default: Self.T) -> Self
  func elementWise(_ rhs: Self.T, _ operation: Mocap4Face.VecBinaryOperator) -> Self
  func elementWise(_ operation: Mocap4Face.VecUnaryOperator) -> Self
  func zero() -> Self
  func one() -> Self
  func floatArray() -> Mocap4Face.KotlinFloatArray
}
@_hasMissingDesignatedInitializers public class VecWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.Vec {
  public typealias T = Mocap4Face.VecWrapper
  public var _wrappedVec: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func plus(_ rhs: Mocap4Face.VecWrapper.T) -> Self
  public func plus(_ rhs_: Swift.Double) -> Self
  public func plus(_ rhs__: Swift.Float) -> Self
  public func minus(_ rhs: Mocap4Face.VecWrapper.T) -> Self
  public func minus(_ rhs_: Swift.Double) -> Self
  public func minus(_ rhs__: Swift.Float) -> Self
  public func times(_ rhs: Swift.Double) -> Self
  public func times(_ rhs_: Swift.Float) -> Self
  public func times(_ rhs__: Mocap4Face.VecWrapper.T) -> Self
  public func div(_ rhs: Swift.Double) -> Self
  public func div(_ rhs_: Swift.Float) -> Self
  public func div(_ rhs__: Mocap4Face.VecWrapper.T) -> Self
  public func unaryMinus() -> Self
  public func invDiv(_ rhs: Swift.Double) -> Self
  public func invDiv(_ rhs_: Swift.Float) -> Self
  public func sum() -> Swift.Float
  public func length_() -> Swift.Float
  public func min() -> Swift.Float
  public func max() -> Swift.Float
  public func dot(_ rhs: Mocap4Face.VecWrapper.T) -> Swift.Float
  public func normalized() -> Self?
  public func normalized(_ default: Mocap4Face.VecWrapper.T) -> Self
  public func elementWise(_ rhs: Mocap4Face.VecWrapper.T, _ operation: Mocap4Face.VecBinaryOperator) -> Self
  public func elementWise(_ operation: Mocap4Face.VecUnaryOperator) -> Self
  public func zero() -> Self
  public func one() -> Self
  public func floatArray() -> Mocap4Face.KotlinFloatArray
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Vector : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.Vec {
  public typealias T = Mocap4Face.Vector
  public var _wrappedVec: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ elements: Mocap4Face.KotlinFloatArray)
  public func factory(_ elements: Mocap4Face.KotlinFloatArray) -> Self
  public func plus(_ rhs: Mocap4Face.Vector.T) -> Self
  public func plus(_ rhs_: Swift.Double) -> Self
  public func plus(_ rhs__: Swift.Float) -> Self
  public func minus(_ rhs: Mocap4Face.Vector.T) -> Self
  public func minus(_ rhs_: Swift.Double) -> Self
  public func minus(_ rhs__: Swift.Float) -> Self
  public func times(_ rhs__: Mocap4Face.Vector.T) -> Self
  public func times(_ rhs: Swift.Double) -> Self
  public func times(_ rhs_: Swift.Float) -> Self
  public func div(_ rhs__: Mocap4Face.Vector.T) -> Self
  public func div(_ rhs: Swift.Double) -> Self
  public func div(_ rhs_: Swift.Float) -> Self
  public func unaryMinus() -> Self
  public func invDiv(_ rhs: Swift.Double) -> Self
  public func invDiv(_ rhs_: Swift.Float) -> Self
  public func sum() -> Swift.Float
  public func length_() -> Swift.Float
  public func min() -> Swift.Float
  public func max() -> Swift.Float
  public func dot(_ rhs: Mocap4Face.Vector.T) -> Swift.Float
  public func normalized() -> Self?
  public func normalized(_ default: Mocap4Face.Vector.T) -> Self
  public func elementWise(_ rhs: Mocap4Face.Vector.T, _ operation: Mocap4Face.VecBinaryOperator) -> Self
  public func elementWise(_ operation: Mocap4Face.VecUnaryOperator) -> Self
  public func zero() -> Self
  public func one() -> Self
  public func floatArray() -> Mocap4Face.KotlinFloatArray
  public func asList() -> [Swift.Float]
  public func description() -> Swift.String
  public func vecMulMat<M>(_ mat: M) -> Self where M : Mocap4Face.Matrix
  public static func matMulVec<M, V>(_ mat: M, _ vec: V) -> V where M : Mocap4Face.Matrix, V : Mocap4Face.Vector
  public static func == (lhs: Mocap4Face.Vector, rhs: Mocap4Face.Vector) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Col : Mocap4Face.Vector {
  public typealias T = Mocap4Face.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ r: Swift.Double, _ g: Swift.Double, _ b: Swift.Double, _ a: Swift.Double)
  convenience public init(_ r: Swift.Double, _ g: Swift.Double, _ b: Swift.Double)
  convenience public init(_ r: Swift.Float, _ g: Swift.Float, _ b: Swift.Float, _ a_: Swift.Float)
  convenience public init(_ r: Swift.Float, _ g: Swift.Float, _ b_: Swift.Float)
  convenience public init(_ r: Swift.Int, _ g: Swift.Int, _ b: Swift.Int, _ a__: Swift.Int)
  convenience public init(_ r: Swift.Int, _ g: Swift.Int, _ b__: Swift.Int)
  convenience public init()
  convenience public init(_ color: Swift.Int, _ channelMap: Mocap4Face.KotlinIntArray = RGB)
  public var r: Swift.Float {
    get
  }
  public var g: Swift.Float {
    get
  }
  public var b: Swift.Float {
    get
  }
  public var a: Swift.Float {
    get
  }
  public var rgb: Mocap4Face.Col {
    get
  }
  public var xy: Mocap4Face.Vec2 {
    get
  }
  public var xyz: Mocap4Face.Vec3 {
    get
  }
  public var xyzw: Mocap4Face.Vec4 {
    get
  }
  public static var RGBA: Mocap4Face.KotlinIntArray {
    get
  }
  public static var BGRA: Mocap4Face.KotlinIntArray {
    get
  }
  public static var RGB: Mocap4Face.KotlinIntArray {
    get
  }
  public static var BGR: Mocap4Face.KotlinIntArray {
    get
  }
  public func withR(_ r: Swift.Float) -> Mocap4Face.Col
  public func withG(_ g: Swift.Float) -> Mocap4Face.Col
  public func withB(_ b: Swift.Float) -> Mocap4Face.Col
  public func withA(_ a: Swift.Float) -> Mocap4Face.Col
  public func toInt(_ channelMap: Mocap4Face.KotlinIntArray = RGBA) -> Swift.Int
  public func clamp() -> Mocap4Face.Col
  public static func == (lhs: Mocap4Face.Col, rhs: Mocap4Face.Col) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ComputationTree<K, V, C> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ rootKey: K, _ rootValue: V, _ context: C, _ nodes: Any)
  public var rootKey: K {
    get
  }
  public var rootValue: V {
    get
  }
  public var context: C {
    get
  }
  public func compute(_ key: K) -> V?
  public func updated(_ rootValue: V, _ context: C) -> Mocap4Face.ComputationTree<K, V, C>
  public static func == (lhs: Mocap4Face.ComputationTree<K, V, C>, rhs: Mocap4Face.ComputationTree<K, V, C>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ComputationTreeNode<K, V, C> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ key: K, _ parentKey: K, _ computation: @escaping (V, C) -> V)
  public var key: K {
    get
  }
  public var parentKey: K {
    get
  }
  public var computation: (V, C) -> V {
    get
  }
  public static func == (lhs: Mocap4Face.ComputationTreeNode<K, V, C>, rhs: Mocap4Face.ComputationTreeNode<K, V, C>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ComputeExpression : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ scale: Swift.Float, _ bias: Swift.Float, _ min: Swift.Float?, _ max: Swift.Float?)
  public func evaluate(_ variables: [Swift.String : Swift.Float]) -> Swift.Float
  public func finish(_ x: Swift.Float) -> Swift.Float
  public static func == (lhs: Mocap4Face.ComputeExpression, rhs: Mocap4Face.ComputeExpression) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension ComputeExpression {
  @_hasMissingDesignatedInitializers public class Variable : Mocap4Face.ComputeExpression {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ name: Swift.String, _ default: @escaping () -> Swift.Float, _ scale: Swift.Float, _ bias: Swift.Float, _ min: Swift.Float?, _ max: Swift.Float?)
    public static func == (lhs: Mocap4Face.ComputeExpression.Variable, rhs: Mocap4Face.ComputeExpression.Variable) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension ComputeExpression {
  @_hasMissingDesignatedInitializers public class Value : Mocap4Face.ComputeExpression {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ value: Swift.Float, _ scale: Swift.Float, _ bias: Swift.Float, _ min: Swift.Float?, _ max: Swift.Float?)
    public static func == (lhs: Mocap4Face.ComputeExpression.Value, rhs: Mocap4Face.ComputeExpression.Value) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension ComputeExpression {
  @_hasMissingDesignatedInitializers public class Sum : Mocap4Face.ComputeExpression {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ operands: [Mocap4Face.ComputeExpression], _ scale: Swift.Float, _ bias: Swift.Float, _ min: Swift.Float?, _ max: Swift.Float?)
    public static func == (lhs: Mocap4Face.ComputeExpression.Sum, rhs: Mocap4Face.ComputeExpression.Sum) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension ComputeExpression {
  @_hasMissingDesignatedInitializers public class Product : Mocap4Face.ComputeExpression {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ operands: [Mocap4Face.ComputeExpression], _ scale: Swift.Float, _ bias: Swift.Float, _ min: Swift.Float?, _ max: Swift.Float?)
    public static func == (lhs: Mocap4Face.ComputeExpression.Product, rhs: Mocap4Face.ComputeExpression.Product) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension ComputeExpression {
  @_hasMissingDesignatedInitializers public class Max : Mocap4Face.ComputeExpression {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ operands: [Mocap4Face.ComputeExpression], _ scale: Swift.Float, _ bias: Swift.Float, _ min: Swift.Float?, _ max: Swift.Float?)
    public static func == (lhs: Mocap4Face.ComputeExpression.Max, rhs: Mocap4Face.ComputeExpression.Max) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension ComputeExpression {
  @_hasMissingDesignatedInitializers public class Min : Mocap4Face.ComputeExpression {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ operands: [Mocap4Face.ComputeExpression], _ scale: Swift.Float, _ bias: Swift.Float, _ min: Swift.Float?, _ max: Swift.Float?)
    public static func == (lhs: Mocap4Face.ComputeExpression.Min, rhs: Mocap4Face.ComputeExpression.Min) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension ComputeExpression {
  @_hasMissingDesignatedInitializers public class If : Mocap4Face.ComputeExpression {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ condition: Mocap4Face.ComputeExpression, _ trueExpression: Mocap4Face.ComputeExpression, _ falseExpression: Mocap4Face.ComputeExpression, _ scale: Swift.Float, _ bias: Swift.Float, _ min: Swift.Float?, _ max: Swift.Float?)
    public static func == (lhs: Mocap4Face.ComputeExpression.If, rhs: Mocap4Face.ComputeExpression.If) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension ComputeExpression {
  @_hasMissingDesignatedInitializers public class Pow : Mocap4Face.ComputeExpression {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ base: Mocap4Face.ComputeExpression, _ exponent: Mocap4Face.ComputeExpression, _ scale: Swift.Float, _ bias: Swift.Float, _ min: Swift.Float?, _ max: Swift.Float?)
    public static func == (lhs: Mocap4Face.ComputeExpression.Pow, rhs: Mocap4Face.ComputeExpression.Pow) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension ComputeExpression {
  @_hasMissingDesignatedInitializers public class Abs : Mocap4Face.ComputeExpression {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ x: Mocap4Face.ComputeExpression, _ scale: Swift.Float, _ bias: Swift.Float, _ min: Swift.Float?, _ max: Swift.Float?)
    public static func == (lhs: Mocap4Face.ComputeExpression.Abs, rhs: Mocap4Face.ComputeExpression.Abs) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers public class MatrixLayout : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public var transposed: Mocap4Face.MatrixLayout {
    get
  }
  public static var default_: Mocap4Face.MatrixLayout {
    get
  }
  public func invoke(_ row: Swift.Int, _ column: Swift.Int, _ order: Swift.Int) -> Swift.Int
  public static func == (lhs: Mocap4Face.MatrixLayout, rhs: Mocap4Face.MatrixLayout) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension MatrixLayout {
  @_hasMissingDesignatedInitializers public class RowMajorClass : Mocap4Face.MatrixLayout {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    override public var transposed: Mocap4Face.MatrixLayout.ColumnMajorClass {
      get
    }
    public static func == (lhs: Mocap4Face.MatrixLayout.RowMajorClass, rhs: Mocap4Face.MatrixLayout.RowMajorClass) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
  public static var RowMajor: Mocap4Face.MatrixLayout.RowMajorClass {
    get
  }
}
extension MatrixLayout {
  @_hasMissingDesignatedInitializers public class ColumnMajorClass : Mocap4Face.MatrixLayout {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    override public var transposed: Mocap4Face.MatrixLayout.RowMajorClass {
      get
    }
    public static func == (lhs: Mocap4Face.MatrixLayout.ColumnMajorClass, rhs: Mocap4Face.MatrixLayout.ColumnMajorClass) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
  public static var ColumnMajor: Mocap4Face.MatrixLayout.ColumnMajorClass {
    get
  }
}
@_hasMissingDesignatedInitializers public class Matrix : Mocap4Face.Vector {
  public typealias T = Mocap4Face.Matrix
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ elements: Mocap4Face.KotlinFloatArray, _ order: Swift.Int, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_)
  public var order: Swift.Int {
    get
  }
  public var layout: Mocap4Face.MatrixLayout {
    get
  }
  public func factory(_ elements: Mocap4Face.KotlinFloatArray, _ order: Swift.Int, _ layout: Mocap4Face.MatrixLayout) -> Self
  public func transposed() -> Self
  public func transposedLayout() -> Self
  public func mul(_ rhs: Mocap4Face.Matrix.T) -> Self
  public func inverse() -> Self?
  public func inverse(_ default: Mocap4Face.Matrix.T) -> Self
  public static func == (lhs: Mocap4Face.Matrix, rhs: Mocap4Face.Matrix) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Mat2 : Mocap4Face.Matrix {
  public typealias T = Mocap4Face.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ x: Mocap4Face.Vec2, _ y: Mocap4Face.Vec2, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_)
  convenience public init(_ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_)
  public var x: Mocap4Face.Vec2 {
    get
  }
  public var y: Mocap4Face.Vec2 {
    get
  }
  public var mat2: Mocap4Face.Mat2 {
    get
  }
  public var mat3: Mocap4Face.Mat3 {
    get
  }
  public var mat4: Mocap4Face.Mat4 {
    get
  }
  public func withX(_ x: Mocap4Face.Vec2) -> Mocap4Face.Mat2
  public func withY(_ y: Mocap4Face.Vec2) -> Mocap4Face.Mat2
  public func withZ(_ z: Mocap4Face.Vec3) -> Mocap4Face.Mat3
  public func mul(_ rhs_: Mocap4Face.Vec2) -> Mocap4Face.Vec2
  public func scale() -> Mocap4Face.Vec2
  public static func identity(_ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat2
  public static func scale(_ x: Swift.Double, _ y: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat2
  public static func scale(_ x: Swift.Float, _ y: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat2
  public static func scale(_ vec: Mocap4Face.Vec2, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat2
  public static func translate(_ x: Swift.Double, _ y: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat2
  public static func translate(_ x: Swift.Float, _ y: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat2
  public static func translate(_ vec: Mocap4Face.Vec2, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat2
  public static func rotate(_ angle: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat2
  public static func rotate(_ angle: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat2
  public static func == (lhs: Mocap4Face.Mat2, rhs: Mocap4Face.Mat2) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Mat3 : Mocap4Face.Matrix {
  public typealias T = Mocap4Face.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ x: Mocap4Face.Vec3, _ y: Mocap4Face.Vec3, _ z: Mocap4Face.Vec3, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_)
  convenience public init(_ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_)
  public var x: Mocap4Face.Vec3 {
    get
  }
  public var y: Mocap4Face.Vec3 {
    get
  }
  public var z: Mocap4Face.Vec3 {
    get
  }
  public var mat2: Mocap4Face.Mat2 {
    get
  }
  public var mat3: Mocap4Face.Mat3 {
    get
  }
  public var mat4: Mocap4Face.Mat4 {
    get
  }
  public func withX(_ x: Mocap4Face.Vec3) -> Mocap4Face.Mat3
  public func withY(_ y: Mocap4Face.Vec3) -> Mocap4Face.Mat3
  public func withZ(_ z: Mocap4Face.Vec3) -> Mocap4Face.Mat3
  public func withW(_ w: Mocap4Face.Vec4) -> Mocap4Face.Mat4
  public func mul(_ rhs_: Mocap4Face.Vec3) -> Mocap4Face.Vec3
  public func mul(_ rhs__: Mocap4Face.Quaternion) -> Mocap4Face.Mat3
  public func quaternion() -> Mocap4Face.Quaternion
  public func scale() -> Mocap4Face.Vec3
  public func scale2() -> Mocap4Face.Vec2
  public func translation() -> Mocap4Face.Vec2
  public func rotation() -> Mocap4Face.Quaternion
  public static func identity(_ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func scale(_ x: Swift.Double, _ y: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func scale(_ x: Swift.Float, _ y: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func scale(_ vec: Mocap4Face.Vec2, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func scale(_ x: Swift.Double, _ y: Swift.Double, _ z: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func scale(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func scale(_ vec: Mocap4Face.Vec3, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func translate(_ x: Swift.Double, _ y: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func translate(_ x: Swift.Float, _ y: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func translate(_ vec: Mocap4Face.Vec2, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func translate(_ x: Swift.Double, _ y: Swift.Double, _ z: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func translate(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func translate(_ vec: Mocap4Face.Vec3, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func rotate(_ angleX: Swift.Double, _ angleY: Swift.Double, _ angleZ: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func rotate(_ angleX: Swift.Float, _ angleY: Swift.Float, _ angleZ: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func rotate(_ angle: Swift.Double, _ axis: Mocap4Face.Vec3, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func rotate(_ angle: Swift.Float, _ axis: Mocap4Face.Vec3, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func rotate(_ cosAngle: Swift.Double, _ sinAngle: Swift.Double, _ axis: Mocap4Face.Vec3, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func rotate(_ cosAngle: Swift.Float, _ sinAngle: Swift.Float, _ axis: Mocap4Face.Vec3, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func rotate(_ v1: Mocap4Face.Vec3, _ v2: Mocap4Face.Vec3, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func rotateX(_ angle: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func rotateX(_ angle: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func rotateY(_ angle: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func rotateY(_ angle: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func rotateZ(_ angle: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func rotateZ(_ angle: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public static func == (lhs: Mocap4Face.Mat3, rhs: Mocap4Face.Mat3) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Mat4 : Mocap4Face.Matrix {
  public typealias T = Mocap4Face.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ x: Mocap4Face.Vec4, _ y: Mocap4Face.Vec4, _ z: Mocap4Face.Vec4, _ w: Mocap4Face.Vec4, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_)
  convenience public init(_ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_)
  public var x: Mocap4Face.Vec4 {
    get
  }
  public var y: Mocap4Face.Vec4 {
    get
  }
  public var z: Mocap4Face.Vec4 {
    get
  }
  public var w: Mocap4Face.Vec4 {
    get
  }
  public var mat2: Mocap4Face.Mat2 {
    get
  }
  public var mat3: Mocap4Face.Mat3 {
    get
  }
  public var mat4: Mocap4Face.Mat4 {
    get
  }
  public func withX(_ x: Mocap4Face.Vec4) -> Mocap4Face.Mat4
  public func withY(_ y: Mocap4Face.Vec4) -> Mocap4Face.Mat4
  public func withZ(_ z: Mocap4Face.Vec4) -> Mocap4Face.Mat4
  public func withW(_ w: Mocap4Face.Vec4) -> Mocap4Face.Mat4
  public func mul(_ rhs_: Mocap4Face.Vec4) -> Mocap4Face.Vec4
  public func mul(_ rhs__: Mocap4Face.Quaternion) -> Mocap4Face.Mat4
  public func quaternion() -> Mocap4Face.Quaternion
  public func scale() -> Mocap4Face.Vec3
  public func translation() -> Mocap4Face.Vec3
  public func rotation() -> Mocap4Face.Quaternion
  public static func identity(_ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func scale(_ x: Swift.Double, _ y: Swift.Double, _ z: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func scale(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func scale(_ vec: Mocap4Face.Vec3, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func scale(_ x: Swift.Double, _ y: Swift.Double, _ z: Swift.Double, _ w: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func scale(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ w: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func scale(_ vec: Mocap4Face.Vec4, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func translate(_ x: Swift.Double, _ y: Swift.Double, _ z: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func translate(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func translate(_ vec: Mocap4Face.Vec3, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func translate(_ x: Swift.Double, _ y: Swift.Double, _ z: Swift.Double, _ w: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func translate(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ w: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func translate(_ vec: Mocap4Face.Vec4, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func rotate(_ angleX: Swift.Double, _ angleY: Swift.Double, _ angleZ: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func rotate(_ angleX: Swift.Float, _ angleY: Swift.Float, _ angleZ: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func rotate(_ angleXYZ: Mocap4Face.Vec3, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func rotate(_ angle: Swift.Double, _ axis: Mocap4Face.Vec3, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func rotate(_ angle: Swift.Float, _ axis: Mocap4Face.Vec3, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func rotate(_ cosAngle: Swift.Double, _ sinAngle: Swift.Double, _ axis: Mocap4Face.Vec3, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func rotate(_ cosAngle: Swift.Float, _ sinAngle: Swift.Float, _ axis: Mocap4Face.Vec3, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func rotate(_ v1: Mocap4Face.Vec3, _ v2: Mocap4Face.Vec3, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func rotateX(_ angle: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func rotateX(_ angle: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func rotateY(_ angle: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func rotateY(_ angle: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func rotateZ(_ angle: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func rotateZ(_ angle: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func viewRH(_ eye: Mocap4Face.Vec3, _ view: Mocap4Face.Vec3, _ up: Mocap4Face.Vec3, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func orthoRH(_ w: Swift.Double, _ h: Swift.Double, _ zNear: Swift.Double, _ zFar: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func orthoRH(_ w: Swift.Float, _ h: Swift.Float, _ zNear: Swift.Float, _ zFar: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func perspRH(_ fov: Swift.Double, _ aspect: Swift.Double, _ zNear: Swift.Double, _ zFar: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func perspRH(_ fov: Swift.Float, _ aspect: Swift.Float, _ zNear: Swift.Float, _ zFar: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func perspRHSymmetricZ(_ fov: Swift.Double, _ aspect: Swift.Double, _ zNear: Swift.Double, _ zFar: Swift.Double, _ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func perspRHSymmetricZ(_ fov: Swift.Float, _ aspect: Swift.Float, _ zNear: Swift.Float, _ zFar: Swift.Float, _ layout_: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func == (lhs: Mocap4Face.Mat4, rhs: Mocap4Face.Mat4) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Quaternion : Mocap4Face.Vector {
  public typealias T = Mocap4Face.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ r: Swift.Double, _ i: Swift.Double, _ j: Swift.Double, _ k: Swift.Double)
  convenience public init(_ r: Swift.Float, _ i: Swift.Float, _ j: Swift.Float, _ k_: Swift.Float)
  convenience public init(_ vec: Mocap4Face.Vec4)
  convenience public init()
  public var r: Swift.Float {
    get
  }
  public var i: Swift.Float {
    get
  }
  public var j: Swift.Float {
    get
  }
  public var k: Swift.Float {
    get
  }
  public var ijk: Mocap4Face.Vec3 {
    get
  }
  public var xyzw: Mocap4Face.Vec4 {
    get
  }
  public var mat3RowMajor: Mocap4Face.Mat3 {
    get
  }
  public var mat3ColumnMajor: Mocap4Face.Mat3 {
    get
  }
  public var mat4RowMajor: Mocap4Face.Mat4 {
    get
  }
  public var mat4ColumnMajor: Mocap4Face.Mat4 {
    get
  }
  public static var identity: Mocap4Face.Quaternion {
    get
  }
  public func withR(_ r: Swift.Float) -> Mocap4Face.Quaternion
  public func withI(_ i: Swift.Float) -> Mocap4Face.Quaternion
  public func withJ(_ j: Swift.Float) -> Mocap4Face.Quaternion
  public func withK(_ k: Swift.Float) -> Mocap4Face.Quaternion
  public func mul(_ rhs: Mocap4Face.Quaternion) -> Mocap4Face.Quaternion
  public func mul(_ rhs_: Mocap4Face.Mat3) -> Mocap4Face.Mat3
  public func mul(_ rhs__: Mocap4Face.Mat4) -> Mocap4Face.Mat4
  public func mul(_ rhs___: Mocap4Face.Vec3) -> Mocap4Face.Vec3
  public func inverse() -> Mocap4Face.Quaternion
  public func log() -> Mocap4Face.Quaternion
  public func exp() -> Mocap4Face.Quaternion
  public func toRotation() -> Mocap4Face.KotlinPair<Swift.Float, Mocap4Face.Vec3>
  public func toEuler() -> Mocap4Face.Vec3
  public func slerp(_ q: Mocap4Face.Quaternion, _ t: Swift.Float) -> Mocap4Face.Quaternion
  public func spline(_ q1: Mocap4Face.Quaternion, _ q2: Mocap4Face.Quaternion, _ q3: Mocap4Face.Quaternion, _ t: Swift.Float) -> Mocap4Face.Quaternion
  public func toMat3(_ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat3
  public func toMat4(_ layout: Mocap4Face.MatrixLayout = MatrixLayout.default_) -> Mocap4Face.Mat4
  public static func fromMatrix(_ mat: Mocap4Face.Mat4) -> Mocap4Face.Quaternion
  public static func fromRotation(_ angle: Swift.Float, _ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float) -> Mocap4Face.Quaternion
  public static func fromRotation(_ angle: Swift.Float, _ vec: Mocap4Face.Vec3) -> Mocap4Face.Quaternion
  public static func fromEuler(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float) -> Mocap4Face.Quaternion
  public static func fromEuler(_ vec: Mocap4Face.Vec3) -> Mocap4Face.Quaternion
  public static func == (lhs: Mocap4Face.Quaternion, rhs: Mocap4Face.Quaternion) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
public protocol RandomTransform {
  var _wrappedRandomTransform: Swift.AnyObject { get }
  func invoke(_ x: Swift.Float) -> Swift.Float
}
@_hasMissingDesignatedInitializers public class RandomTransformWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.RandomTransform {
  public var _wrappedRandomTransform: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func invoke(_ x: Swift.Float) -> Swift.Float
  @objc deinit
}
public protocol RandomDistributionFactory {
  var _wrappedRandomDistributionFactory: Swift.AnyObject { get }
  func invoke() -> Mocap4Face.RandomTransform
  func invoke(_ centre: Swift.Float) -> Mocap4Face.RandomTransform
}
@_hasMissingDesignatedInitializers public class RandomDistributionFactoryWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.RandomDistributionFactory {
  public var _wrappedRandomDistributionFactory: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func invoke() -> Mocap4Face.RandomTransform
  public func invoke(_ centre: Swift.Float) -> Mocap4Face.RandomTransform
  @objc deinit
}
@_hasMissingDesignatedInitializers public class RandomValue : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ distribution: Mocap4Face.RandomDistributionFactory, _ seed: Swift.Int64?, _ randomTransform: Mocap4Face.RandomTransform)
  public var min: Swift.Float {
    get
  }
  public var max: Swift.Float {
    get
  }
  public var range: Swift.Float {
    get
  }
  public var distribution: Mocap4Face.RandomDistributionFactory {
    get
  }
  public func invoke_() -> Swift.Float
  public static func normalized(_ seed: Swift.Int64? = nil) -> Mocap4Face.RandomValue.Normalized
  public static func normalized(_ kurtosis: Swift.Float, _ rareShare: Swift.Float = Float(0.1).n, _ seed: Swift.Int64? = nil) -> Mocap4Face.RandomValue.Normalized
  public static func normalized(_ mode: Swift.Float, _ kurtosis: Swift.Float, _ rareShare: Swift.Float = Float(0.1).n, _ modeIsMedian: Swift.Bool = false, _ seed: Swift.Int64? = nil) -> Mocap4Face.RandomValue.NormalizedAsymmetric
  public static func zeroed(_ seed: Swift.Int64? = nil) -> Mocap4Face.RandomValue.IntervalSymmetric
  public static func zeroed(_ kurtosis: Swift.Float, _ rareShare: Swift.Float = Float(0.1).n, _ seed: Swift.Int64? = nil) -> Mocap4Face.RandomValue.IntervalSymmetric
  public static func zeroed(_ mode: Swift.Float, _ kurtosis: Swift.Float, _ rareShare: Swift.Float = Float(0.1).n, _ modeIsMedian: Swift.Bool = false, _ seed: Swift.Int64? = nil) -> Mocap4Face.RandomValue.IntervalAsymmetric
  public static func interval(_ lowerBound: Swift.Float, _ upperBound: Swift.Float, _ seed: Swift.Int64? = nil) -> Mocap4Face.RandomValue.IntervalSymmetric
  public static func interval(_ lowerBound: Swift.Float, _ upperBound: Swift.Float, _ kurtosis: Swift.Float, _ rareShare: Swift.Float = Float(0.1).n, _ seed: Swift.Int64? = nil) -> Mocap4Face.RandomValue.IntervalSymmetric
  public static func interval(_ lowerBound: Swift.Float, _ upperBound: Swift.Float, _ mode: Swift.Float, _ kurtosis: Swift.Float, _ rareShare: Swift.Float = Float(0.1).n, _ modeIsMedian: Swift.Bool = false, _ seed: Swift.Int64? = nil) -> Mocap4Face.RandomValue.IntervalAsymmetric
  public static func create(_ lowerBound: Swift.Float? = nil, _ upperBound: Swift.Float? = nil, _ mode: Swift.Float? = nil, _ kurtosis: Swift.Float? = nil, _ rareShare: Swift.Float = Float(0.1).n, _ modeIsMedian: Swift.Bool = false, _ seed: Swift.Int64? = nil) -> Mocap4Face.RandomValue
  public static func == (lhs: Mocap4Face.RandomValue, rhs: Mocap4Face.RandomValue) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension RandomValue {
  @_hasMissingDesignatedInitializers public class Normalized : Mocap4Face.RandomValue {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ distribution: Mocap4Face.RandomDistributionFactory, _ seed: Swift.Int64? = nil)
    public static func == (lhs: Mocap4Face.RandomValue.Normalized, rhs: Mocap4Face.RandomValue.Normalized) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension RandomValue {
  @_hasMissingDesignatedInitializers public class NormalizedAsymmetric : Mocap4Face.RandomValue {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ centre: Swift.Float, _ distribution: Mocap4Face.RandomDistributionFactory, _ seed: Swift.Int64? = nil)
    public var centre: Swift.Float {
      get
    }
    public static func == (lhs: Mocap4Face.RandomValue.NormalizedAsymmetric, rhs: Mocap4Face.RandomValue.NormalizedAsymmetric) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension RandomValue {
  @_hasMissingDesignatedInitializers public class Interval : Mocap4Face.RandomValue {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ lowerBound: Swift.Float, _ upperBound: Swift.Float, _ distribution: Mocap4Face.RandomDistributionFactory, _ seed: Swift.Int64?, _ randomTransform: Mocap4Face.RandomTransform)
    override public var min: Swift.Float {
      get
    }
    override public var max: Swift.Float {
      get
    }
    override public var range: Swift.Float {
      get
    }
    public var lowerBound: Swift.Float {
      get
    }
    public var upperBound: Swift.Float {
      get
    }
    public static func == (lhs: Mocap4Face.RandomValue.Interval, rhs: Mocap4Face.RandomValue.Interval) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension RandomValue {
  @_hasMissingDesignatedInitializers public class IntervalSymmetric : Mocap4Face.RandomValue.Interval {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ lowerBound: Swift.Float, _ upperBound: Swift.Float, _ distribution: Mocap4Face.RandomDistributionFactory, _ seed: Swift.Int64? = nil)
    public static func == (lhs: Mocap4Face.RandomValue.IntervalSymmetric, rhs: Mocap4Face.RandomValue.IntervalSymmetric) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension RandomValue.Interval {
  public typealias Symmetric = Mocap4Face.RandomValue.IntervalSymmetric
}
extension RandomValue {
  @_hasMissingDesignatedInitializers public class IntervalAsymmetric : Mocap4Face.RandomValue.Interval {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ lowerBound: Swift.Float, _ upperBound: Swift.Float, _ centre: Swift.Float, _ distribution: Mocap4Face.RandomDistributionFactory, _ seed: Swift.Int64? = nil)
    public var centre: Swift.Float {
      get
    }
    public static func == (lhs: Mocap4Face.RandomValue.IntervalAsymmetric, rhs: Mocap4Face.RandomValue.IntervalAsymmetric) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension RandomValue.Interval {
  public typealias Asymmetric = Mocap4Face.RandomValue.IntervalAsymmetric
}
@_hasMissingDesignatedInitializers public class RandomTransformPoly : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.RandomTransform {
  public var _wrappedRandomTransform: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ kurtosis: Swift.Float)
  public var kurtosis: Swift.Float {
    get
  }
  public func invoke(_ x: Swift.Float) -> Swift.Float
  public static func == (lhs: Mocap4Face.RandomTransformPoly, rhs: Mocap4Face.RandomTransformPoly) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class RandomTransformAsymmetric : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.RandomTransform {
  public var _wrappedRandomTransform: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ mode: Swift.Float, _ otherDistribution: Mocap4Face.RandomTransform)
  public var mode: Swift.Float {
    get
  }
  public var otherDistribution: Mocap4Face.RandomTransform {
    get
  }
  public func invoke(_ x: Swift.Float) -> Swift.Float
  public static func == (lhs: Mocap4Face.RandomTransformAsymmetric, rhs: Mocap4Face.RandomTransformAsymmetric) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension RandomTransformAsymmetric {
  @_hasMissingDesignatedInitializers public class Median : Mocap4Face.RandomTransformAsymmetric {
    override public var _wrappedRandomTransform: Swift.AnyObject {
      get
    }
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ mode: Swift.Float, _ otherDistribution: Mocap4Face.RandomTransform)
    public static func == (lhs: Mocap4Face.RandomTransformAsymmetric.Median, rhs: Mocap4Face.RandomTransformAsymmetric.Median) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension RandomTransformAsymmetric {
  @_hasMissingDesignatedInitializers public class Mode : Mocap4Face.RandomTransformAsymmetric.Median {
    override public var _wrappedRandomTransform: Swift.AnyObject {
      get
    }
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ mode: Swift.Float, _ otherDistribution: Mocap4Face.RandomTransform)
    public static func == (lhs: Mocap4Face.RandomTransformAsymmetric.Mode, rhs: Mocap4Face.RandomTransformAsymmetric.Mode) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers public class RandomTransformWithRare : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.RandomTransform {
  public var _wrappedRandomTransform: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ rareShare: Swift.Float, _ otherDistribution: Mocap4Face.RandomTransform)
  public var rareShare: Swift.Float {
    get
  }
  public var otherDistribution: Mocap4Face.RandomTransform {
    get
  }
  public func invoke(_ x: Swift.Float) -> Swift.Float
  public static func == (lhs: Mocap4Face.RandomTransformWithRare, rhs: Mocap4Face.RandomTransformWithRare) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class RandomTransformIdentity : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.RandomTransform {
  public var _wrappedRandomTransform: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func invoke(_ x: Swift.Float) -> Swift.Float
  public static func == (lhs: Mocap4Face.RandomTransformIdentity, rhs: Mocap4Face.RandomTransformIdentity) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class RandomDistributionPoly : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.RandomDistributionFactory {
  public var _wrappedRandomDistributionFactory: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ kurtosis: Swift.Float, _ rareShare: Swift.Float = Float(0.1).n, _ modeIsMedian: Swift.Bool = false)
  public var kurtosis: Swift.Float {
    get
  }
  public var rareShare: Swift.Float {
    get
  }
  public var modeIsMedian: Swift.Bool {
    get
  }
  public func invoke() -> Mocap4Face.RandomTransform
  public func invoke(_ centre: Swift.Float) -> Mocap4Face.RandomTransform
  public static func == (lhs: Mocap4Face.RandomDistributionPoly, rhs: Mocap4Face.RandomDistributionPoly) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class RandomDistributionUniform : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.RandomDistributionFactory {
  public var _wrappedRandomDistributionFactory: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func invoke() -> Mocap4Face.RandomTransform
  public func invoke(_ centre: Swift.Float) -> Mocap4Face.RandomTransform
  public static func == (lhs: Mocap4Face.RandomDistributionUniform, rhs: Mocap4Face.RandomDistributionUniform) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Stabilizer {
  associatedtype T : Mocap4Face.Vec
  var _wrappedStabilizer: Swift.AnyObject { get }
  func stabilize<TStabilizer>(_ newValue: Self.T) -> Mocap4Face.KotlinPair<TStabilizer, Self.T> where TStabilizer : Mocap4Face.Stabilizer, Self.T == TStabilizer.T
}
@_hasMissingDesignatedInitializers public class StabilizerWrapper<T> : Mocap4Face.ConvertibleToKotlin, Mocap4Face.Stabilizer where T : Mocap4Face.Vec {
  public typealias T = T
  public var _wrappedStabilizer: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func stabilize<TStabilizer>(_ newValue: T) -> Mocap4Face.KotlinPair<TStabilizer, T> where T == TStabilizer.T, TStabilizer : Mocap4Face.Stabilizer
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SNRStabilizer<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.Stabilizer where T : Mocap4Face.Vec {
  public typealias T = T
  public var _wrappedStabilizer: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ smoothing: Swift.Float, _ snr: Swift.Float, _ signalSmoothingRatio: Swift.Float = Float(0.01).n)
  public func stabilize<TStabilizer>(_ newValue: T) -> Mocap4Face.KotlinPair<TStabilizer, T> where T == TStabilizer.T, TStabilizer : Mocap4Face.Stabilizer
  public static func == (lhs: Mocap4Face.SNRStabilizer<T>, rhs: Mocap4Face.SNRStabilizer<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class SNRStabilizerVec<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.Stabilizer where T : Mocap4Face.Vec {
  public typealias T = T
  public var _wrappedStabilizer: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ smoothing: T, _ snr: T, _ signalSmoothingRatio: Swift.Float = Float(0.01).n)
  public func stabilize<TStabilizer>(_ newValue: T) -> Mocap4Face.KotlinPair<TStabilizer, T> where T == TStabilizer.T, TStabilizer : Mocap4Face.Stabilizer
  public static func == (lhs: Mocap4Face.SNRStabilizerVec<T>, rhs: Mocap4Face.SNRStabilizerVec<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class NoiseDetectStabilizer<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.Stabilizer where T : Mocap4Face.Vec {
  public typealias T = T
  public var _wrappedStabilizer: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ smoothing: Swift.Float, _ noise: Swift.Float, _ sampleCount: Swift.Int)
  public func stabilize<TStabilizer>(_ newValue: T) -> Mocap4Face.KotlinPair<TStabilizer, T> where T == TStabilizer.T, TStabilizer : Mocap4Face.Stabilizer
  public static func == (lhs: Mocap4Face.NoiseDetectStabilizer<T>, rhs: Mocap4Face.NoiseDetectStabilizer<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ChainedStabilizer<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.Stabilizer where T : Mocap4Face.Vec {
  public typealias T = T
  public var _wrappedStabilizer: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init<TStabilizer>(_ stabilizers: [TStabilizer]) where T == TStabilizer.T, TStabilizer : Mocap4Face.Stabilizer
  public func stabilize<TStabilizer>(_ newValue: T) -> Mocap4Face.KotlinPair<TStabilizer, T> where T == TStabilizer.T, TStabilizer : Mocap4Face.Stabilizer
  public static func == (lhs: Mocap4Face.ChainedStabilizer<T>, rhs: Mocap4Face.ChainedStabilizer<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AveragedStabilizer<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.Stabilizer where T : Mocap4Face.Vec {
  public typealias T = T
  public var _wrappedStabilizer: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init<TStabilizer>(_ stabilizers: [TStabilizer]) where T == TStabilizer.T, TStabilizer : Mocap4Face.Stabilizer
  public func stabilize<TStabilizer>(_ newValue: T) -> Mocap4Face.KotlinPair<TStabilizer, T> where T == TStabilizer.T, TStabilizer : Mocap4Face.Stabilizer
  public static func == (lhs: Mocap4Face.AveragedStabilizer<T>, rhs: Mocap4Face.AveragedStabilizer<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DummyStabilizer<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.Stabilizer where T : Mocap4Face.Vec {
  public typealias T = T
  public var _wrappedStabilizer: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func stabilize<TStabilizer>(_ newValue: T) -> Mocap4Face.KotlinPair<TStabilizer, T> where T == TStabilizer.T, TStabilizer : Mocap4Face.Stabilizer
  public static func == (lhs: Mocap4Face.DummyStabilizer<T>, rhs: Mocap4Face.DummyStabilizer<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ThresholdStabilizer<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.Stabilizer where T : Mocap4Face.Vec {
  public typealias T = T
  public var _wrappedStabilizer: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init<TStabilizer>(_ below: TStabilizer, _ above: TStabilizer, _ threshold: Swift.Float) where T == TStabilizer.T, TStabilizer : Mocap4Face.Stabilizer
  public func stabilize<TStabilizer>(_ newValue: T) -> Mocap4Face.KotlinPair<TStabilizer, T> where T == TStabilizer.T, TStabilizer : Mocap4Face.Stabilizer
  public static func == (lhs: Mocap4Face.ThresholdStabilizer<T>, rhs: Mocap4Face.ThresholdStabilizer<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol VecUnaryOperator {
  var _wrappedVecUnaryOperator: Swift.AnyObject { get }
  func invoke(_ a: Swift.Float) -> Swift.Float
}
@_hasMissingDesignatedInitializers public class VecUnaryOperatorWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.VecUnaryOperator {
  public var _wrappedVecUnaryOperator: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func invoke(_ a: Swift.Float) -> Swift.Float
  @objc deinit
}
public protocol VecBinaryOperator {
  var _wrappedVecBinaryOperator: Swift.AnyObject { get }
  func invoke(_ a: Swift.Float, _ b: Swift.Float) -> Swift.Float
}
@_hasMissingDesignatedInitializers public class VecBinaryOperatorWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.VecBinaryOperator {
  public var _wrappedVecBinaryOperator: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func invoke(_ a: Swift.Float, _ b: Swift.Float) -> Swift.Float
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Vec1 : Mocap4Face.Vector {
  public typealias T = Mocap4Face.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ x: Swift.Double)
  convenience public init(_ x_: Swift.Float)
  convenience public init(_ x__: Swift.Int)
  convenience public init()
  public var x: Swift.Float {
    get
  }
  public var xy: Mocap4Face.Vec2 {
    get
  }
  public var xyz: Mocap4Face.Vec3 {
    get
  }
  public var xyzw: Mocap4Face.Vec4 {
    get
  }
  public static var xAxis: Mocap4Face.Vec1 {
    get
  }
  public static var zero: Mocap4Face.Vec1 {
    get
  }
  public static var one: Mocap4Face.Vec1 {
    get
  }
  public func withX(_ x: Swift.Float) -> Mocap4Face.Vec1
  public func withY(_ y: Swift.Float) -> Mocap4Face.Vec2
  public static func == (lhs: Mocap4Face.Vec1, rhs: Mocap4Face.Vec1) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Vec2 : Mocap4Face.Vector {
  public typealias T = Mocap4Face.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ x: Swift.Double, _ y: Swift.Double)
  convenience public init(_ x: Swift.Float, _ y_: Swift.Float)
  convenience public init(_ x: Swift.Int, _ y__: Swift.Int)
  convenience public init()
  public var x: Swift.Float {
    get
  }
  public var y: Swift.Float {
    get
  }
  public var xy: Mocap4Face.Vec2 {
    get
  }
  public var xyz: Mocap4Face.Vec3 {
    get
  }
  public var xyzw: Mocap4Face.Vec4 {
    get
  }
  public static var xAxis: Mocap4Face.Vec2 {
    get
  }
  public static var yAxis: Mocap4Face.Vec2 {
    get
  }
  public static var zero: Mocap4Face.Vec2 {
    get
  }
  public static var one: Mocap4Face.Vec2 {
    get
  }
  public func withX(_ x: Swift.Float) -> Mocap4Face.Vec2
  public func withY(_ y: Swift.Float) -> Mocap4Face.Vec2
  public func withZ(_ z: Swift.Float) -> Mocap4Face.Vec3
  public func mul(_ mat: Mocap4Face.Mat2) -> Mocap4Face.Vec2
  public static func == (lhs: Mocap4Face.Vec2, rhs: Mocap4Face.Vec2) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Vec3 : Mocap4Face.Vector {
  public typealias T = Mocap4Face.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ x: Swift.Double, _ y: Swift.Double, _ z: Swift.Double)
  convenience public init(_ x: Swift.Float, _ y: Swift.Float, _ z_: Swift.Float)
  convenience public init(_ x: Swift.Int, _ y: Swift.Int, _ z__: Swift.Int)
  convenience public init(_ xy: Mocap4Face.Vec2, _ z: Swift.Float)
  convenience public init(_ xyz: Swift.Float)
  convenience public init()
  public var x: Swift.Float {
    get
  }
  public var y: Swift.Float {
    get
  }
  public var z: Swift.Float {
    get
  }
  public var xy: Mocap4Face.Vec2 {
    get
  }
  public var xyz: Mocap4Face.Vec3 {
    get
  }
  public var xyzw: Mocap4Face.Vec4 {
    get
  }
  public var rgb: Mocap4Face.Col {
    get
  }
  public static var xAxis: Mocap4Face.Vec3 {
    get
  }
  public static var yAxis: Mocap4Face.Vec3 {
    get
  }
  public static var zAxis: Mocap4Face.Vec3 {
    get
  }
  public static var zero: Mocap4Face.Vec3 {
    get
  }
  public static var one: Mocap4Face.Vec3 {
    get
  }
  public func withX(_ x: Swift.Float) -> Mocap4Face.Vec3
  public func withY(_ y: Swift.Float) -> Mocap4Face.Vec3
  public func withZ(_ z: Swift.Float) -> Mocap4Face.Vec3
  public func withW(_ w: Swift.Float) -> Mocap4Face.Vec4
  public func cross(_ rhs: Mocap4Face.Vec3) -> Mocap4Face.Vec3
  public func mul(_ mat: Mocap4Face.Mat3) -> Mocap4Face.Vec3
  public func mul(_ rhs: Mocap4Face.Quaternion) -> Mocap4Face.Vec3
  public static func == (lhs: Mocap4Face.Vec3, rhs: Mocap4Face.Vec3) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Vec4 : Mocap4Face.Vector {
  public typealias T = Mocap4Face.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ x: Swift.Double, _ y: Swift.Double, _ z: Swift.Double, _ w: Swift.Double)
  convenience public init(_ x: Swift.Float, _ y: Swift.Float, _ z: Swift.Float, _ w_: Swift.Float)
  convenience public init(_ x: Swift.Int, _ y: Swift.Int, _ z: Swift.Int, _ w__: Swift.Int)
  convenience public init(_ xy: Mocap4Face.Vec2, _ z: Swift.Float)
  convenience public init(_ xy: Mocap4Face.Vec2, _ z: Swift.Float, _ w: Swift.Float)
  convenience public init(_ xy: Mocap4Face.Vec2, _ zw: Mocap4Face.Vec2)
  convenience public init(_ xyz: Mocap4Face.Vec3)
  convenience public init(_ xyz: Mocap4Face.Vec3, _ w: Swift.Float)
  convenience public init()
  public var x: Swift.Float {
    get
  }
  public var y: Swift.Float {
    get
  }
  public var z: Swift.Float {
    get
  }
  public var w: Swift.Float {
    get
  }
  public var xy: Mocap4Face.Vec2 {
    get
  }
  public var xyz: Mocap4Face.Vec3 {
    get
  }
  public var xyzw: Mocap4Face.Vec4 {
    get
  }
  public var rgb: Mocap4Face.Col {
    get
  }
  public var rgba: Mocap4Face.Col {
    get
  }
  public static var xAxis: Mocap4Face.Vec4 {
    get
  }
  public static var yAxis: Mocap4Face.Vec4 {
    get
  }
  public static var zAxis: Mocap4Face.Vec4 {
    get
  }
  public static var wAxis: Mocap4Face.Vec4 {
    get
  }
  public static var zero: Mocap4Face.Vec4 {
    get
  }
  public static var one: Mocap4Face.Vec4 {
    get
  }
  public func withX(_ x: Swift.Float) -> Mocap4Face.Vec4
  public func withY(_ y: Swift.Float) -> Mocap4Face.Vec4
  public func withZ(_ z: Swift.Float) -> Mocap4Face.Vec4
  public func withW(_ w: Swift.Float) -> Mocap4Face.Vec4
  public func dehomog() -> Mocap4Face.Vec3?
  public func mul(_ mat: Mocap4Face.Mat4) -> Mocap4Face.Vec4
  public static func == (lhs: Mocap4Face.Vec4, rhs: Mocap4Face.Vec4) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
public protocol Tuple {
  var _wrappedTuple: Swift.AnyObject { get }
  func toArray() -> Mocap4Face.KotlinArray<Any?>
  func toList() -> [Any]
}
@_hasMissingDesignatedInitializers public class TupleWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.Tuple {
  public var _wrappedTuple: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func toArray() -> Mocap4Face.KotlinArray<Any?>
  public func toList() -> [Any]
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Tuple1<T0> : Mocap4Face.ConvertibleToKotlin, Mocap4Face.Tuple {
  public var _wrappedTuple: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ _0: T0)
  public var _0: T0 {
    get
  }
  public func toArray() -> Mocap4Face.KotlinArray<Any?>
  public func toList() -> [Any]
  public func applyTo<R>(_ fn: @escaping (T0) -> R) -> R
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func description() -> Swift.String
  public func component1() -> T0
  public func doCopy(_ _0: T0) -> Mocap4Face.Tuple1<T0>
  public func tryAll<T0Ext>() -> Mocap4Face.Try<Mocap4Face.Tuple1<T0Ext>> where T0 : Mocap4Face.Try<T0Ext>
  public func all<T0Ext>() -> Mocap4Face.Tuple1<T0Ext>?
  public func zip<T0Ext>() -> [Mocap4Face.Tuple1<T0Ext>]
  public static func == (lhs: Mocap4Face.Tuple1<T0>, rhs: Mocap4Face.Tuple1<T0>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Tuple2<T0, T1> : Mocap4Face.ConvertibleToKotlin, Mocap4Face.Tuple {
  public var _wrappedTuple: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ _0: T0, _ _1: T1)
  public var _0: T0 {
    get
  }
  public var _1: T1 {
    get
  }
  public func toArray() -> Mocap4Face.KotlinArray<Any?>
  public func toList() -> [Any]
  public func applyTo<R>(_ fn: @escaping (T0, T1) -> R) -> R
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func description() -> Swift.String
  public func component1() -> T0
  public func component2() -> T1
  public func doCopy(_ _0: T0, _ _1: T1) -> Mocap4Face.Tuple2<T0, T1>
  public func tryAll<T0Ext, T1Ext>() -> Mocap4Face.Try<Mocap4Face.Tuple2<T0Ext, T1Ext>> where T0 : Mocap4Face.Try<T0Ext>, T1 : Mocap4Face.Try<T1Ext>
  public func all<T0Ext, T1Ext>() -> Mocap4Face.Tuple2<T0Ext, T1Ext>?
  public func zip<T0Ext, T1Ext>() -> [Mocap4Face.Tuple2<T0Ext, T1Ext>]
  public func matchCombinations<TExt, UExt, R>(_ both: @escaping (TExt, UExt) -> R, _ first: @escaping (TExt, Mocap4Face.TryError) -> R, _ second: @escaping (Mocap4Face.TryError, UExt) -> R, _ none: @escaping (Mocap4Face.TryError, Mocap4Face.TryError) -> R) -> R where T0 : Mocap4Face.Try<TExt>, T1 : Mocap4Face.Try<UExt>
  public static func == (lhs: Mocap4Face.Tuple2<T0, T1>, rhs: Mocap4Face.Tuple2<T0, T1>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Tuple3<T0, T1, T2> : Mocap4Face.ConvertibleToKotlin, Mocap4Face.Tuple {
  public var _wrappedTuple: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ _0: T0, _ _1: T1, _ _2: T2)
  public var _0: T0 {
    get
  }
  public var _1: T1 {
    get
  }
  public var _2: T2 {
    get
  }
  public func toArray() -> Mocap4Face.KotlinArray<Any?>
  public func toList() -> [Any]
  public func applyTo<R>(_ fn: @escaping (T0, T1, T2) -> R) -> R
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func description() -> Swift.String
  public func component1() -> T0
  public func component2() -> T1
  public func component3() -> T2
  public func doCopy(_ _0: T0, _ _1: T1, _ _2: T2) -> Mocap4Face.Tuple3<T0, T1, T2>
  public func tryAll<T0Ext, T1Ext, T2Ext>() -> Mocap4Face.Try<Mocap4Face.Tuple3<T0Ext, T1Ext, T2Ext>> where T0 : Mocap4Face.Try<T0Ext>, T1 : Mocap4Face.Try<T1Ext>, T2 : Mocap4Face.Try<T2Ext>
  public func all<T0Ext, T1Ext, T2Ext>() -> Mocap4Face.Tuple3<T0Ext, T1Ext, T2Ext>?
  public func zip<T0Ext, T1Ext, T2Ext>() -> [Mocap4Face.Tuple3<T0Ext, T1Ext, T2Ext>]
  public static func == (lhs: Mocap4Face.Tuple3<T0, T1, T2>, rhs: Mocap4Face.Tuple3<T0, T1, T2>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Tuple4<T0, T1, T2, T3> : Mocap4Face.ConvertibleToKotlin, Mocap4Face.Tuple {
  public var _wrappedTuple: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ _0: T0, _ _1: T1, _ _2: T2, _ _3: T3)
  public var _0: T0 {
    get
  }
  public var _1: T1 {
    get
  }
  public var _2: T2 {
    get
  }
  public var _3: T3 {
    get
  }
  public func toArray() -> Mocap4Face.KotlinArray<Any?>
  public func toList() -> [Any]
  public func applyTo<R>(_ fn: @escaping (T0, T1, T2, T3) -> R) -> R
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func description() -> Swift.String
  public func component1() -> T0
  public func component2() -> T1
  public func component3() -> T2
  public func component4() -> T3
  public func doCopy(_ _0: T0, _ _1: T1, _ _2: T2, _ _3: T3) -> Mocap4Face.Tuple4<T0, T1, T2, T3>
  public func tryAll<T0Ext, T1Ext, T2Ext, T3Ext>() -> Mocap4Face.Try<Mocap4Face.Tuple4<T0Ext, T1Ext, T2Ext, T3Ext>> where T0 : Mocap4Face.Try<T0Ext>, T1 : Mocap4Face.Try<T1Ext>, T2 : Mocap4Face.Try<T2Ext>, T3 : Mocap4Face.Try<T3Ext>
  public func all<T0Ext, T1Ext, T2Ext, T3Ext>() -> Mocap4Face.Tuple4<T0Ext, T1Ext, T2Ext, T3Ext>?
  public func zip<T0Ext, T1Ext, T2Ext, T3Ext>() -> [Mocap4Face.Tuple4<T0Ext, T1Ext, T2Ext, T3Ext>]
  public static func == (lhs: Mocap4Face.Tuple4<T0, T1, T2, T3>, rhs: Mocap4Face.Tuple4<T0, T1, T2, T3>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Tuple5<T0, T1, T2, T3, T4> : Mocap4Face.ConvertibleToKotlin, Mocap4Face.Tuple {
  public var _wrappedTuple: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ _0: T0, _ _1: T1, _ _2: T2, _ _3: T3, _ _4: T4)
  public var _0: T0 {
    get
  }
  public var _1: T1 {
    get
  }
  public var _2: T2 {
    get
  }
  public var _3: T3 {
    get
  }
  public var _4: T4 {
    get
  }
  public func toArray() -> Mocap4Face.KotlinArray<Any?>
  public func toList() -> [Any]
  public func applyTo<R>(_ fn: @escaping (T0, T1, T2, T3, T4) -> R) -> R
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func description() -> Swift.String
  public func component1() -> T0
  public func component2() -> T1
  public func component3() -> T2
  public func component4() -> T3
  public func component5() -> T4
  public func doCopy(_ _0: T0, _ _1: T1, _ _2: T2, _ _3: T3, _ _4: T4) -> Mocap4Face.Tuple5<T0, T1, T2, T3, T4>
  public func tryAll<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext>() -> Mocap4Face.Try<Mocap4Face.Tuple5<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext>> where T0 : Mocap4Face.Try<T0Ext>, T1 : Mocap4Face.Try<T1Ext>, T2 : Mocap4Face.Try<T2Ext>, T3 : Mocap4Face.Try<T3Ext>, T4 : Mocap4Face.Try<T4Ext>
  public func all<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext>() -> Mocap4Face.Tuple5<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext>?
  public func zip<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext>() -> [Mocap4Face.Tuple5<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext>]
  public static func == (lhs: Mocap4Face.Tuple5<T0, T1, T2, T3, T4>, rhs: Mocap4Face.Tuple5<T0, T1, T2, T3, T4>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Tuple6<T0, T1, T2, T3, T4, T5> : Mocap4Face.ConvertibleToKotlin, Mocap4Face.Tuple {
  public var _wrappedTuple: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ _0: T0, _ _1: T1, _ _2: T2, _ _3: T3, _ _4: T4, _ _5: T5)
  public var _0: T0 {
    get
  }
  public var _1: T1 {
    get
  }
  public var _2: T2 {
    get
  }
  public var _3: T3 {
    get
  }
  public var _4: T4 {
    get
  }
  public var _5: T5 {
    get
  }
  public func toArray() -> Mocap4Face.KotlinArray<Any?>
  public func toList() -> [Any]
  public func applyTo<R>(_ fn: @escaping (T0, T1, T2, T3, T4, T5) -> R) -> R
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func description() -> Swift.String
  public func component1() -> T0
  public func component2() -> T1
  public func component3() -> T2
  public func component4() -> T3
  public func component5() -> T4
  public func component6() -> T5
  public func doCopy(_ _0: T0, _ _1: T1, _ _2: T2, _ _3: T3, _ _4: T4, _ _5: T5) -> Mocap4Face.Tuple6<T0, T1, T2, T3, T4, T5>
  public func tryAll<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext>() -> Mocap4Face.Try<Mocap4Face.Tuple6<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext>> where T0 : Mocap4Face.Try<T0Ext>, T1 : Mocap4Face.Try<T1Ext>, T2 : Mocap4Face.Try<T2Ext>, T3 : Mocap4Face.Try<T3Ext>, T4 : Mocap4Face.Try<T4Ext>, T5 : Mocap4Face.Try<T5Ext>
  public func all<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext>() -> Mocap4Face.Tuple6<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext>?
  public func zip<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext>() -> [Mocap4Face.Tuple6<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext>]
  public static func == (lhs: Mocap4Face.Tuple6<T0, T1, T2, T3, T4, T5>, rhs: Mocap4Face.Tuple6<T0, T1, T2, T3, T4, T5>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Tuple7<T0, T1, T2, T3, T4, T5, T6> : Mocap4Face.ConvertibleToKotlin, Mocap4Face.Tuple {
  public var _wrappedTuple: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ _0: T0, _ _1: T1, _ _2: T2, _ _3: T3, _ _4: T4, _ _5: T5, _ _6: T6)
  public var _0: T0 {
    get
  }
  public var _1: T1 {
    get
  }
  public var _2: T2 {
    get
  }
  public var _3: T3 {
    get
  }
  public var _4: T4 {
    get
  }
  public var _5: T5 {
    get
  }
  public var _6: T6 {
    get
  }
  public func toArray() -> Mocap4Face.KotlinArray<Any?>
  public func toList() -> [Any]
  public func applyTo<R>(_ fn: @escaping (T0, T1, T2, T3, T4, T5, T6) -> R) -> R
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func description() -> Swift.String
  public func component1() -> T0
  public func component2() -> T1
  public func component3() -> T2
  public func component4() -> T3
  public func component5() -> T4
  public func component6() -> T5
  public func component7() -> T6
  public func doCopy(_ _0: T0, _ _1: T1, _ _2: T2, _ _3: T3, _ _4: T4, _ _5: T5, _ _6: T6) -> Mocap4Face.Tuple7<T0, T1, T2, T3, T4, T5, T6>
  public func tryAll<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext, T6Ext>() -> Mocap4Face.Try<Mocap4Face.Tuple7<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext, T6Ext>> where T0 : Mocap4Face.Try<T0Ext>, T1 : Mocap4Face.Try<T1Ext>, T2 : Mocap4Face.Try<T2Ext>, T3 : Mocap4Face.Try<T3Ext>, T4 : Mocap4Face.Try<T4Ext>, T5 : Mocap4Face.Try<T5Ext>, T6 : Mocap4Face.Try<T6Ext>
  public func all<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext, T6Ext>() -> Mocap4Face.Tuple7<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext, T6Ext>?
  public func zip<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext, T6Ext>() -> [Mocap4Face.Tuple7<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext, T6Ext>]
  public static func == (lhs: Mocap4Face.Tuple7<T0, T1, T2, T3, T4, T5, T6>, rhs: Mocap4Face.Tuple7<T0, T1, T2, T3, T4, T5, T6>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Tuple8<T0, T1, T2, T3, T4, T5, T6, T7> : Mocap4Face.ConvertibleToKotlin, Mocap4Face.Tuple {
  public var _wrappedTuple: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ _0: T0, _ _1: T1, _ _2: T2, _ _3: T3, _ _4: T4, _ _5: T5, _ _6: T6, _ _7: T7)
  public var _0: T0 {
    get
  }
  public var _1: T1 {
    get
  }
  public var _2: T2 {
    get
  }
  public var _3: T3 {
    get
  }
  public var _4: T4 {
    get
  }
  public var _5: T5 {
    get
  }
  public var _6: T6 {
    get
  }
  public var _7: T7 {
    get
  }
  public func toArray() -> Mocap4Face.KotlinArray<Any?>
  public func toList() -> [Any]
  public func applyTo<R>(_ fn: @escaping (T0, T1, T2, T3, T4, T5, T6, T7) -> R) -> R
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func description() -> Swift.String
  public func component1() -> T0
  public func component2() -> T1
  public func component3() -> T2
  public func component4() -> T3
  public func component5() -> T4
  public func component6() -> T5
  public func component7() -> T6
  public func component8() -> T7
  public func doCopy(_ _0: T0, _ _1: T1, _ _2: T2, _ _3: T3, _ _4: T4, _ _5: T5, _ _6: T6, _ _7: T7) -> Mocap4Face.Tuple8<T0, T1, T2, T3, T4, T5, T6, T7>
  public func tryAll<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext, T6Ext, T7Ext>() -> Mocap4Face.Try<Mocap4Face.Tuple8<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext, T6Ext, T7Ext>> where T0 : Mocap4Face.Try<T0Ext>, T1 : Mocap4Face.Try<T1Ext>, T2 : Mocap4Face.Try<T2Ext>, T3 : Mocap4Face.Try<T3Ext>, T4 : Mocap4Face.Try<T4Ext>, T5 : Mocap4Face.Try<T5Ext>, T6 : Mocap4Face.Try<T6Ext>, T7 : Mocap4Face.Try<T7Ext>
  public func all<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext, T6Ext, T7Ext>() -> Mocap4Face.Tuple8<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext, T6Ext, T7Ext>?
  public func zip<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext, T6Ext, T7Ext>() -> [Mocap4Face.Tuple8<T0Ext, T1Ext, T2Ext, T3Ext, T4Ext, T5Ext, T6Ext, T7Ext>]
  public static func == (lhs: Mocap4Face.Tuple8<T0, T1, T2, T3, T4, T5, T6, T7>, rhs: Mocap4Face.Tuple8<T0, T1, T2, T3, T4, T5, T6, T7>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class LateInit<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func get() -> T
  public static func create<T, U>(_ dependencyProducer: @escaping (Mocap4Face.LateInit<T>) -> U, _ lateInitializer: @escaping (U) -> T) -> U
  public static func == (lhs: Mocap4Face.LateInit<T>, rhs: Mocap4Face.LateInit<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Try<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public var optional: T? {
    get
  }
  public var exception: Mocap4Face.KotlinException? {
    get
  }
  public var bool_: Swift.Bool {
    get
  }
  public var orThrow: T {
    get
  }
  public func flatMap<U>(_ mapper: @escaping (T) -> Mocap4Face.Try<U>) -> Mocap4Face.Try<U>
  public func flatZipMap<U>(_ mapper: @escaping (T) -> Mocap4Face.Try<U>) -> Mocap4Face.Try<Mocap4Face.Tuple2<T, U>>
  public func map<U>(_ mapper: @escaping (T) -> U) -> Mocap4Face.Try<U>
  public func zipMap<U>(_ mapper: @escaping (T) -> U) -> Mocap4Face.Try<Mocap4Face.Tuple2<T, U>>
  public func `catch`(_ catcher: @escaping (Mocap4Face.KotlinException) -> T) -> T
  public func catchError(_ catcher: @escaping (Mocap4Face.TryError) -> T) -> T
  public func or(_ fn: @escaping (Mocap4Face.TryError) -> Mocap4Face.Try<T>) -> Mocap4Face.Try<T>
  public func flatten<TExt>() -> Mocap4Face.Try<TExt> where T : Mocap4Face.Try<TExt>
  public func logError(_ prefix: Swift.String? = nil) -> T?
  public func logWarning(_ prefix: Swift.String? = nil) -> T?
  public func logInfo(_ prefix: Swift.String? = nil) -> T?
  public func logDebug(_ prefix: Swift.String? = nil) -> T?
  public func logInternal(_ prefix: Swift.String? = nil) -> T?
  public func `defer`<TExt>() -> Mocap4Face.Future<Mocap4Face.Try<TExt>> where T : Mocap4Face.Future<TExt>
  public func defer_<TExt>() -> Mocap4Face.Observable<Mocap4Face.Try<TExt>> where T : Mocap4Face.Observable<TExt>
  public func squash<TExt>() -> Mocap4Face.Future<Mocap4Face.Try<TExt>> where T : Mocap4Face.Future<Mocap4Face.Try<TExt>>
  public static func invoke<T>(_ fn: @escaping () -> T) -> Mocap4Face.Try<T>
  public static func invoke<T>(_ errorContext: Swift.String, _ fn: @escaping () -> T) -> Mocap4Face.Try<T>
  public static func success<T>(_ value: T) -> Mocap4Face.Try<T>
  public static func error<T>(_ exception: Mocap4Face.KotlinException) -> Mocap4Face.Try<T>
  public static func error<T>(_ message: Swift.String) -> Mocap4Face.Try<T>
  public static func all<T>(_ items: [Mocap4Face.Try<T>]) -> Mocap4Face.Try<[T]>
  public static func == (lhs: Mocap4Face.Try<T>, rhs: Mocap4Face.Try<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TryValue<T> : Mocap4Face.Try<T> {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ value: T)
  public var value: T {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func description() -> Swift.String
  public func component1() -> T
  public func doCopy(_ value: T) -> Mocap4Face.TryValue<T>
  public static func == (lhs: Mocap4Face.TryValue<T>, rhs: Mocap4Face.TryValue<T>) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class TryError : Mocap4Face.Try<Swift.Never> {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ message: Swift.String)
  convenience public init(_ error: Mocap4Face.KotlinException)
  public var error: Mocap4Face.KotlinException {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func description() -> Swift.String
  public func component1() -> Mocap4Face.KotlinException
  public func doCopy(_ error: Mocap4Face.KotlinException) -> Mocap4Face.TryError
  public static func == (lhs: Mocap4Face.TryError, rhs: Mocap4Face.TryError) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FacemojiAPIClass : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var isFullyActivated: Swift.Bool {
    get
  }
  public var isDemoMode: Swift.Bool {
    get
  }
  public func initialize(_ apiKey: Swift.String, _ context: Mocap4Face.ApplicationContext) -> Mocap4Face.Future<Swift.Bool>
  public func addDemoTimeoutCallback(_ cb: @escaping () -> Swift.Void)
  public static func == (lhs: Mocap4Face.FacemojiAPIClass, rhs: Mocap4Face.FacemojiAPIClass) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public let FacemojiAPI: Mocap4Face.FacemojiAPIClass
public enum LogLevel : Swift.CustomStringConvertible, Mocap4Face.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case debug
  case `internal`
  case info
  case warning
  case error
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: Mocap4Face.LogLevel, b: Mocap4Face.LogLevel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Logger : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public static var logLevel: Mocap4Face.LogLevel {
    get
    set(newValue)
  }
  public static var printLogWithListeners: Swift.Bool {
    get
    set(newValue)
  }
  public static func log(_ level: Mocap4Face.LogLevel, _ message: Swift.String, _ logStackTrace: Mocap4Face.KotlinException? = nil)
  public static func addLogListener(_ l: @escaping (Mocap4Face.LogLevel, Swift.String) -> Swift.Void)
  public static func removeLogListener(_ l: @escaping (Mocap4Face.LogLevel, Swift.String) -> Swift.Void)
  public static func time() -> Mocap4Face.TimeLogger
  public static func debug(_ message: Swift.String)
  public static func `internal`(_ message: Swift.String)
  public static func info(_ message: Swift.String)
  public static func warning(_ message: Swift.String)
  public static func error(_ message: Swift.String)
  public static func error(_ error: Mocap4Face.KotlinException)
  public static func error(_ message: Swift.String, _ error: Mocap4Face.KotlinException)
  public static func == (lhs: Mocap4Face.Logger, rhs: Mocap4Face.Logger) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TimeLogger : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ start: Swift.Int64 = getTimeMillis())
  public func log(_ level: Mocap4Face.LogLevel, _ message: Swift.String, _ logStackTrace: Mocap4Face.KotlinException? = nil)
  public func debug(_ message: Swift.String)
  public func `internal`(_ message: Swift.String)
  public func info(_ message: Swift.String)
  public func warning(_ message: Swift.String)
  public func error(_ message: Swift.String)
  public static func == (lhs: Mocap4Face.TimeLogger, rhs: Mocap4Face.TimeLogger) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AtomicReference<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ initialValue: T)
  public func get() -> T
  public func set(_ value: T)
  public func getAndUpdate(_ updateFunction: @escaping (T) -> T) -> T
  public func tryGetAndUpdate(_ updateFunction: @escaping (T) -> T) -> T?
  public static func == (lhs: Mocap4Face.AtomicReference<T>, rhs: Mocap4Face.AtomicReference<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AtomicInt : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ initialValue: Swift.Int)
  public func get() -> Swift.Int
  public func set(_ value: Swift.Int)
  public func getAndUpdate(_ updateFunction: @escaping (Swift.Int) -> Swift.Int) -> Swift.Int
  public func addAndGet(_ delta: Swift.Int) -> Swift.Int
  public static func == (lhs: Mocap4Face.AtomicInt, rhs: Mocap4Face.AtomicInt) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Condition : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public var signaled: Swift.Bool {
    get
  }
  public func waitFor()
  public func waitFor(_ timeoutMillis: Swift.Int) -> Swift.Bool
  public func waitFor(_ timeoutMillis: Swift.Int, _ reset: Swift.Bool) -> Swift.Bool
  public func signalAll()
  public static func == (lhs: Mocap4Face.Condition, rhs: Mocap4Face.Condition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ReentrantLock : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func lock()
  public func tryLock() -> Swift.Bool
  public func unlock()
  public func invoke<T>(_ fn: @escaping () -> T) -> T
  public static func == (lhs: Mocap4Face.ReentrantLock, rhs: Mocap4Face.ReentrantLock) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class SynchronizedList<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public var size: Swift.Int {
    get
  }
  public func add(_ item: T)
  public func clear()
  public func removeAll(_ predicate: @escaping (T) -> Swift.Bool)
  public func get(_ index: Swift.Int) -> T
  public func forEach(_ cb: @escaping (T) -> Swift.Void)
  public func toList() -> [T]
  public static func == (lhs: Mocap4Face.SynchronizedList<T>, rhs: Mocap4Face.SynchronizedList<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DispatchQueue : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ name: Swift.String)
  convenience public init(_ queue: Mocap4Face.DispatchQueueBackend)
  public static var main: Mocap4Face.DispatchQueue {
    get
  }
  public static var current: Mocap4Face.DispatchQueue? {
    get
  }
  public static var globalAsync: Mocap4Face.DispatchQueue {
    get
  }
  public func queue(_ fn: @escaping () -> Swift.Void)
  public func targetsThisThread() -> Swift.Bool?
  public func getCallbackOnThisQueue<T>(_ thisQueueCallback: @escaping (T) -> Swift.Void) -> (T) -> Swift.Void
  public func queueAndWait<T>(_ timeoutMillis: Swift.Int?, _ fn: @escaping () -> T) -> T?
  public func queueAndWait<T>(_ fn: @escaping () -> T) -> T
  public func async<T>(_ fn: @escaping () -> T) -> Mocap4Face.Future<T>
  public static func createSingleThreaded(_ name: Swift.String) -> Mocap4Face.DispatchQueue
  public static func createSystemQueue(_ name: Swift.String) -> Mocap4Face.DispatchQueue
  public static func == (lhs: Mocap4Face.DispatchQueue, rhs: Mocap4Face.DispatchQueue) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class PeriodicExecutor : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ intervalSeconds: Swift.Double, _ fn: @escaping () -> Swift.Void)
  public func cancel()
  public static func == (lhs: Mocap4Face.PeriodicExecutor, rhs: Mocap4Face.PeriodicExecutor) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Future<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ generator: @escaping (@escaping (T) -> Swift.Void) -> Swift.Void)
  convenience public init(_ value: T)
  public var resolved: Swift.Bool {
    get
  }
  public var currentValue: T? {
    get
  }
  public func whenDone(_ consumer: @escaping (T) -> Swift.Void)
  public func peek(_ consumer: @escaping (T) -> Swift.Void) -> Mocap4Face.Future<T>
  public func map<U>(_ mapper: @escaping (T) -> U) -> Mocap4Face.Future<U>
  public func flatMap<U>(_ mapper: @escaping (T) -> Mocap4Face.Future<U>) -> Mocap4Face.Future<U>
  public func waitFor() -> T
  public func waitFor(_ timeoutMillis: Swift.Int) -> T?
  public func logError<TExt>(_ prefix: Swift.String? = nil) -> Mocap4Face.Future<TExt?> where T : Mocap4Face.Try<TExt>
  public func logWarning<TExt>(_ prefix: Swift.String? = nil) -> Mocap4Face.Future<TExt?> where T : Mocap4Face.Try<TExt>
  public func logInfo<TExt>(_ prefix: Swift.String? = nil) -> Mocap4Face.Future<TExt?> where T : Mocap4Face.Try<TExt>
  public func logDebug<TExt>(_ prefix: Swift.String? = nil) -> Mocap4Face.Future<TExt?> where T : Mocap4Face.Try<TExt>
  public func logInternal<TExt>(_ prefix: Swift.String? = nil) -> Mocap4Face.Future<TExt?> where T : Mocap4Face.Try<TExt>
  public func mapTry<TExt, U>(_ mapper: @escaping (TExt) -> U) -> Mocap4Face.Future<Mocap4Face.Try<U>> where T : Mocap4Face.Try<TExt>
  public func mapTryFlat<TExt, U>(_ mapper: @escaping (TExt) -> Mocap4Face.Try<U>) -> Mocap4Face.Future<Mocap4Face.Try<U>> where T : Mocap4Face.Try<TExt>
  public func flatMapTry<TExt, U>(_ mapper: @escaping (TExt) -> Mocap4Face.Future<Mocap4Face.Try<U>>) -> Mocap4Face.Future<Mocap4Face.Try<U>> where T : Mocap4Face.Try<TExt>
  public func flatMapTryFlat<U>(_ mapper: @escaping (T) -> Mocap4Face.Try<Mocap4Face.Future<U>>) -> Mocap4Face.Future<Mocap4Face.Try<U>>
  public func `catch`<TExt>(_ catcher: @escaping (Mocap4Face.KotlinException) -> TExt) -> Mocap4Face.Future<TExt> where T : Mocap4Face.Try<TExt>
  public func orTry<TExt>(_ fn: @escaping (Mocap4Face.TryError) -> Mocap4Face.Try<TExt>) -> Mocap4Face.Future<Mocap4Face.Try<TExt>> where T : Mocap4Face.Try<TExt>
  public func orTryFlat<TExt>(_ fn: @escaping (Mocap4Face.TryError) -> Mocap4Face.Future<Mocap4Face.Try<TExt>>) -> Mocap4Face.Future<Mocap4Face.Try<TExt>> where T : Mocap4Face.Try<TExt>
  public static func any<T>(_ futures: Mocap4Face.KotlinArray<Mocap4Face.Future<T>>) -> Mocap4Face.Future<T>
  public static func all<T>(_ futures: [Mocap4Face.Future<T>]) -> Mocap4Face.Future<[T]>
  public static func async<T>(_ fn: @escaping () -> T) -> Mocap4Face.Future<T>
  public static func == (lhs: Mocap4Face.Future<T>, rhs: Mocap4Face.Future<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Observable<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ generator: @escaping (@escaping (T) -> Swift.Void, @escaping () -> Swift.Void) -> Swift.Void)
  convenience public init(_ futures: Mocap4Face.KotlinArray<Mocap4Face.Future<T>>)
  convenience public init(_ futures_: Any)
  convenience public init(_ value: T)
  public var first: Mocap4Face.Future<T> {
    get
  }
  public var value: T? {
    get
  }
  public var last: Mocap4Face.Future<T?> {
    get
  }
  public var id: Swift.Int {
    get
  }
  public func subscribe(_ observer: @escaping (T) -> Swift.Void)
  public func unsubscribe(_ observer: @escaping (T) -> Swift.Void)
  public func map<U>(_ mapper: @escaping (T) -> U) -> Mocap4Face.Observable<U>
  public func flatMap<U>(_ mapper: @escaping (T) -> Mocap4Face.Observable<U>) -> Mocap4Face.Observable<U>
  public func mapNotNull<U>(_ mapper: @escaping (T) -> U?) -> Mocap4Face.Observable<U>
  public func peek(_ fn: @escaping (T) -> Swift.Void) -> Mocap4Face.Observable<T>
  public func filter(_ fn: @escaping (T) -> Swift.Bool) -> Mocap4Face.Observable<T>
  public func zipSecond<U>(_ withValue: U) -> Mocap4Face.Observable<Mocap4Face.KotlinPair<T, U>>
  public func zipFirst<U>(_ withValue: U) -> Mocap4Face.Observable<Mocap4Face.KotlinPair<U, T>>
  public func zipMap<U>(_ mapper: @escaping (T) -> U) -> Mocap4Face.Observable<Mocap4Face.KotlinPair<T, U>>
  public func mapTry<TExt, U>(_ mapper: @escaping (TExt) -> U) -> Mocap4Face.Observable<Mocap4Face.Try<U>> where T : Mocap4Face.Try<TExt>
  public func mapTryFlat<TExt, U>(_ mapper: @escaping (TExt) -> Mocap4Face.Try<U>) -> Mocap4Face.Observable<Mocap4Face.Try<U>> where T : Mocap4Face.Try<TExt>
  public func flatMapTry<TExt, U>(_ mapper: @escaping (TExt) -> Mocap4Face.Observable<Mocap4Face.Try<U>>) -> Mocap4Face.Observable<Mocap4Face.Try<U>> where T : Mocap4Face.Try<TExt>
  public func flatMapTryFlat<U>(_ mapper: @escaping (T) -> Mocap4Face.Try<Mocap4Face.Observable<U>>) -> Mocap4Face.Observable<Mocap4Face.Try<U>>
  public func `catch`<TExt>(_ catcher: @escaping (Mocap4Face.KotlinException) -> TExt) -> Mocap4Face.Observable<TExt> where T : Mocap4Face.Try<TExt>
  public func orTry<TExt>(_ fn: @escaping (Mocap4Face.TryError) -> Mocap4Face.Try<TExt>) -> Mocap4Face.Observable<Mocap4Face.Try<TExt>> where T : Mocap4Face.Try<TExt>
  public func orTryFlat<TExt>(_ fn: @escaping (Mocap4Face.TryError) -> Mocap4Face.Observable<Mocap4Face.Try<TExt>>) -> Mocap4Face.Observable<Mocap4Face.Try<TExt>> where T : Mocap4Face.Try<TExt>
  public static func any<T>(_ observables: Any) -> Mocap4Face.Observable<T>
  public static func all<T>(_ observables: Any) -> Mocap4Face.Observable<[T]>
  public static func async<T>(_ queue: Mocap4Face.DispatchQueue, _ fn: @escaping () -> T) -> Mocap4Face.Observable<T>
  public static func == (lhs: Mocap4Face.Observable<T>, rhs: Mocap4Face.Observable<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol DispatchQueueBackend {
  var _wrappedDispatchQueueBackend: Swift.AnyObject { get }
  func queue(_ fn: @escaping () -> Swift.Void)
  func targetsThisThread() -> Swift.Bool?
  func getCallbackOnThisQueue<T>(_ thisQueueCallback: @escaping (T) -> Swift.Void) -> (T) -> Swift.Void
}
@_hasMissingDesignatedInitializers public class DispatchQueueBackendWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.DispatchQueueBackend {
  public var _wrappedDispatchQueueBackend: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func queue(_ fn: @escaping () -> Swift.Void)
  public func targetsThisThread() -> Swift.Bool?
  public func getCallbackOnThisQueue<T>(_ thisQueueCallback: @escaping (T) -> Swift.Void) -> (T) -> Swift.Void
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SingleThreadDispatchQueue : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.DispatchQueueBackend {
  public var _wrappedDispatchQueueBackend: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ name: Swift.String)
  public func queue(_ fn: @escaping () -> Swift.Void)
  public func targetsThisThread() -> Swift.Bool?
  public func getCallbackOnThisQueue<T>(_ thisQueueCallback: @escaping (T) -> Swift.Void) -> (T) -> Swift.Void
  public func quit()
  public static func == (lhs: Mocap4Face.SingleThreadDispatchQueue, rhs: Mocap4Face.SingleThreadDispatchQueue) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class SystemDispatchQueue : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.DispatchQueueBackend {
  public var _wrappedDispatchQueueBackend: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ name: Swift.String)
  convenience public init(_ queue: ObjectiveC.NSObject?, _ isSingleThreaded: Swift.Bool)
  public var isSingleThreaded: Swift.Bool {
    get
  }
  public static var main: Mocap4Face.SystemDispatchQueue {
    get
  }
  public static var current: Mocap4Face.SystemDispatchQueue? {
    get
  }
  public static var globalAsync: Mocap4Face.SystemDispatchQueue {
    get
  }
  public func queue(_ fn: @escaping () -> Swift.Void)
  public func targetsThisThread() -> Swift.Bool?
  public func getCallbackOnThisQueue<T>(_ thisQueueCallback: @escaping (T) -> Swift.Void) -> (T) -> Swift.Void
  public static func == (lhs: Mocap4Face.SystemDispatchQueue, rhs: Mocap4Face.SystemDispatchQueue) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public enum FillMode : Swift.CustomStringConvertible, Mocap4Face.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case stretch
  case zoom
  case shrink
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: Mocap4Face.FillMode, b: Mocap4Face.FillMode) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum PixelComponents : Swift.CustomStringConvertible, Mocap4Face.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case r
  case rg
  case rgba
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: Mocap4Face.PixelComponents, b: Mocap4Face.PixelComponents) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Image : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public var width: Swift.Int {
    get
  }
  public var height: Swift.Int {
    get
  }
  public static func == (lhs: Mocap4Face.Image, rhs: Mocap4Face.Image) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension Image {
  @_hasMissingDesignatedInitializers public class RawInt : Mocap4Face.Image {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ width: Swift.Int, _ height: Swift.Int, _ data: Mocap4Face.KotlinIntArray)
    override public var width: Swift.Int {
      get
    }
    override public var height: Swift.Int {
      get
    }
    public var data: Mocap4Face.KotlinIntArray {
      get
    }
    public static func == (lhs: Mocap4Face.Image.RawInt, rhs: Mocap4Face.Image.RawInt) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension Image {
  @_hasMissingDesignatedInitializers public class RawFloat : Mocap4Face.Image {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ width: Swift.Int, _ height: Swift.Int, _ data: Mocap4Face.KotlinFloatArray, _ pixelComponents: Mocap4Face.PixelComponents)
    override public var width: Swift.Int {
      get
    }
    override public var height: Swift.Int {
      get
    }
    public var data: Mocap4Face.KotlinFloatArray {
      get
    }
    public var pixelComponents: Mocap4Face.PixelComponents {
      get
    }
    public static func == (lhs: Mocap4Face.Image.RawFloat, rhs: Mocap4Face.Image.RawFloat) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers public class ImageList : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public static func == (lhs: Mocap4Face.ImageList, rhs: Mocap4Face.ImageList) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension ImageList {
  @_hasMissingDesignatedInitializers public class RawInt : Mocap4Face.ImageList {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ width: Swift.Int, _ height: Swift.Int, _ data: [Mocap4Face.KotlinIntArray])
    public var images: [Mocap4Face.Image.RawInt] {
      get
    }
    public static func == (lhs: Mocap4Face.ImageList.RawInt, rhs: Mocap4Face.ImageList.RawInt) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension ImageList {
  @_hasMissingDesignatedInitializers public class RawFloat : Mocap4Face.ImageList {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ width: Swift.Int, _ height: Swift.Int, _ data: [Mocap4Face.KotlinFloatArray], _ pixelComponents: Mocap4Face.PixelComponents)
    public var images: [Mocap4Face.Image.RawFloat] {
      get
    }
    public static func == (lhs: Mocap4Face.ImageList.RawFloat, rhs: Mocap4Face.ImageList.RawFloat) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers public class ImageCube : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public static func == (lhs: Mocap4Face.ImageCube, rhs: Mocap4Face.ImageCube) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension ImageCube {
  @_hasMissingDesignatedInitializers public class RawInt : Mocap4Face.ImageCube {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ size: Swift.Int, _ xPos: Mocap4Face.KotlinIntArray, _ xNeg: Mocap4Face.KotlinIntArray, _ yPos: Mocap4Face.KotlinIntArray, _ yNeg: Mocap4Face.KotlinIntArray, _ zPos: Mocap4Face.KotlinIntArray, _ zNeg: Mocap4Face.KotlinIntArray)
    public var xPos: Mocap4Face.Image.RawInt {
      get
    }
    public var xNeg: Mocap4Face.Image.RawInt {
      get
    }
    public var yPos: Mocap4Face.Image.RawInt {
      get
    }
    public var yNeg: Mocap4Face.Image.RawInt {
      get
    }
    public var zPos: Mocap4Face.Image.RawInt {
      get
    }
    public var zNeg: Mocap4Face.Image.RawInt {
      get
    }
    public static func == (lhs: Mocap4Face.ImageCube.RawInt, rhs: Mocap4Face.ImageCube.RawInt) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
extension ImageCube {
  @_hasMissingDesignatedInitializers public class RawFloat : Mocap4Face.ImageCube {
    convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
    override public func asKotlin() -> Swift.AnyObject
    convenience public init(_ size: Swift.Int, _ xPos: Mocap4Face.KotlinFloatArray, _ xNeg: Mocap4Face.KotlinFloatArray, _ yPos: Mocap4Face.KotlinFloatArray, _ yNeg: Mocap4Face.KotlinFloatArray, _ zPos: Mocap4Face.KotlinFloatArray, _ zNeg: Mocap4Face.KotlinFloatArray, _ pixelComponents: Mocap4Face.PixelComponents)
    public var xPos: Mocap4Face.Image.RawFloat {
      get
    }
    public var xNeg: Mocap4Face.Image.RawFloat {
      get
    }
    public var yPos: Mocap4Face.Image.RawFloat {
      get
    }
    public var yNeg: Mocap4Face.Image.RawFloat {
      get
    }
    public var zPos: Mocap4Face.Image.RawFloat {
      get
    }
    public var zNeg: Mocap4Face.Image.RawFloat {
      get
    }
    public static func == (lhs: Mocap4Face.ImageCube.RawFloat, rhs: Mocap4Face.ImageCube.RawFloat) -> Swift.Bool
    override public func hash(into hasher: inout Swift.Hasher)
    @objc deinit
  }
}
@_hasMissingDesignatedInitializers public class UIKitImage : Mocap4Face.Image {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ platformImage: UIKit.UIImage)
  override public var width: Swift.Int {
    get
  }
  override public var height: Swift.Int {
    get
  }
  public var platformImage: UIKit.UIImage {
    get
  }
  public static func == (lhs: Mocap4Face.UIKitImage, rhs: Mocap4Face.UIKitImage) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class MetalImage : Mocap4Face.Image {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ texture: Metal.MTLTexture)
  override public var width: Swift.Int {
    get
  }
  override public var height: Swift.Int {
    get
  }
  public var texture: Metal.MTLTexture {
    get
  }
  public static func == (lhs: Mocap4Face.MetalImage, rhs: Mocap4Face.MetalImage) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class Sha256 : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public var h: Mocap4Face.KotlinArray<Swift.UInt> {
    get
    set(newValue)
  }
  public var counter: Swift.Int64 {
    get
    set(newValue)
  }
  public var bufferCounter: Swift.Int {
    get
    set(newValue)
  }
  public var buffer: Any {
    get
    set(newValue)
  }
  public var digested: Swift.Bool {
    get
    set(newValue)
  }
  public static var MAX_HASH_BYTES: Swift.Int {
    get
  }
  public static var HEX_DIGEST_LENGTH: Swift.Int {
    get
  }
  public func update(_ data: Any)
  public func digest() -> Any
  public static func digest(_ inputMessage: Swift.String) -> Any
  public static func digest(_ inputMessage_: Any) -> Any
  public static func createExpansionArray(_ originalSizeInBytes: Swift.Int64) -> Any
  public static func == (lhs: Mocap4Face.Sha256, rhs: Mocap4Face.Sha256) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FaceTrackerResult : Mocap4Face.ConvertibleToKotlin {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ blendshapes: [Swift.String : Swift.Float], _ normalizedImagePosition: Mocap4Face.Vec2, _ normalizedImageScale: Swift.Float, _ rotationQuaternion: Mocap4Face.Quaternion, _ confidence: Swift.Float, _ inputImageSize: Mocap4Face.Vec2, _ cropRect: Mocap4Face.Rect, _ positionInCrop: Mocap4Face.Vec2, _ scaleInCrop: Swift.Float, _ debug: Any? = nil)
  public var blendshapes: [Swift.String : Swift.Float] {
    get
  }
  public var normalizedImagePosition: Mocap4Face.Vec2 {
    get
  }
  public var normalizedImageScale: Swift.Float {
    get
  }
  public var rotationQuaternion: Mocap4Face.Quaternion {
    get
  }
  public var confidence: Swift.Float {
    get
  }
  public var inputImageSize: Mocap4Face.Vec2 {
    get
  }
  public var debug: Any? {
    get
  }
  public static var EMPTY: Mocap4Face.FaceTrackerResult {
    get
  }
  public func hasFace() -> Swift.Bool
  public func interpolate(_ other: Mocap4Face.FaceTrackerResult, _ t: Swift.Float) -> Mocap4Face.FaceTrackerResult
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func description() -> Swift.String
  public func component1() -> [Swift.String : Swift.Float]
  public func component2() -> Mocap4Face.Vec2
  public func component3() -> Swift.Float
  public func component4() -> Mocap4Face.Quaternion
  public func component5() -> Swift.Float
  public func component6() -> Mocap4Face.Vec2
  public func component10() -> Any?
  public func doCopy(_ blendshapes: [Swift.String : Swift.Float], _ normalizedImagePosition: Mocap4Face.Vec2, _ normalizedImageScale: Swift.Float, _ rotationQuaternion: Mocap4Face.Quaternion, _ confidence: Swift.Float, _ inputImageSize: Mocap4Face.Vec2, _ cropRect: Mocap4Face.Rect, _ positionInCrop: Mocap4Face.Vec2, _ scaleInCrop: Swift.Float, _ debug: Any? = nil) -> Mocap4Face.FaceTrackerResult
  public func serialize(_ customData: Mocap4Face.KotlinByteArray? = nil) -> Mocap4Face.KotlinByteArray
  public static func == (lhs: Mocap4Face.FaceTrackerResult, rhs: Mocap4Face.FaceTrackerResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FaceTrackerWithResult : Mocap4Face.ConvertibleToKotlin {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ tracker: Mocap4Face.PersistentFaceTracker, _ result: Mocap4Face.FaceTrackerResult?)
  public var tracker: Mocap4Face.PersistentFaceTracker {
    get
  }
  public var result: Mocap4Face.FaceTrackerResult? {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func description() -> Swift.String
  public func component1() -> Mocap4Face.PersistentFaceTracker
  public func component2() -> Mocap4Face.FaceTrackerResult?
  public func doCopy(_ tracker: Mocap4Face.PersistentFaceTracker, _ result: Mocap4Face.FaceTrackerResult?) -> Mocap4Face.FaceTrackerWithResult
  public static func == (lhs: Mocap4Face.FaceTrackerWithResult, rhs: Mocap4Face.FaceTrackerWithResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TrackerImage : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ image: CoreVideo.CVBuffer)
  public var width: Swift.Int {
    get
  }
  public var height: Swift.Int {
    get
  }
  public var image: CoreVideo.CVBuffer {
    get
  }
  public func toUIImage() -> Mocap4Face.Try<UIKit.UIImage>
  public static func == (lhs: Mocap4Face.TrackerImage, rhs: Mocap4Face.TrackerImage) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TrackerGPUContext : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public static func == (lhs: Mocap4Face.TrackerGPUContext, rhs: Mocap4Face.TrackerGPUContext) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol PersistentFaceTracker {
  var _wrappedPersistentFaceTracker: Swift.AnyObject { get }
  var version: Swift.String { get }
  var blendshapeNames: [Swift.String] { get }
  func track(_ image: Mocap4Face.TrackerImage) -> Mocap4Face.FaceTrackerWithResult
}
@_hasMissingDesignatedInitializers public class PersistentFaceTrackerWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.PersistentFaceTracker {
  public var _wrappedPersistentFaceTracker: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var version: Swift.String {
    get
  }
  public var blendshapeNames: [Swift.String] {
    get
  }
  public func track(_ image: Mocap4Face.TrackerImage) -> Mocap4Face.FaceTrackerWithResult
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FaceTracker : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var lastResult: Mocap4Face.FaceTrackerResult? {
    get
  }
  public var blendshapeNames: [Swift.String] {
    get
  }
  public func track(_ image: Mocap4Face.TrackerImage) -> Mocap4Face.FaceTrackerResult?
  public static func createVideoTracker(_ fileSystem: Mocap4Face.FileSystem, _ context: Mocap4Face.TrackerGPUContext) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.FaceTracker>>
  public static func createImageTracker(_ fileSystem: Mocap4Face.FileSystem, _ context: Mocap4Face.TrackerGPUContext) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.FaceTracker>>
  public static func == (lhs: Mocap4Face.FaceTracker, rhs: Mocap4Face.FaceTracker) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol FaceTrackerFactory {
  var _wrappedFaceTrackerFactory: Swift.AnyObject { get }
  func create(_ fileSystem: Mocap4Face.FileSystem, _ context: Mocap4Face.TrackerGPUContext) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.PersistentFaceTracker>>
}
@_hasMissingDesignatedInitializers public class FaceTrackerFactoryWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.FaceTrackerFactory {
  public var _wrappedFaceTrackerFactory: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func create(_ fileSystem: Mocap4Face.FileSystem, _ context: Mocap4Face.TrackerGPUContext) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.PersistentFaceTracker>>
  @objc deinit
}
public protocol FaceTrackerReprojector {
  var _wrappedFaceTrackerReprojector: Swift.AnyObject { get }
  func reproject(_ trackerResult: Mocap4Face.FaceTrackerResult) -> Mocap4Face.FaceTrackerReprojectorResult
  func reproject(_ normalizedImagePosition: Mocap4Face.Vec2, _ normalizedImageScale: Swift.Float) -> Mocap4Face.FaceTrackerReprojectorResult
}
@_hasMissingDesignatedInitializers public class FaceTrackerReprojectorWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.FaceTrackerReprojector {
  public var _wrappedFaceTrackerReprojector: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func reproject(_ trackerResult: Mocap4Face.FaceTrackerResult) -> Mocap4Face.FaceTrackerReprojectorResult
  public func reproject(_ normalizedImagePosition: Mocap4Face.Vec2, _ normalizedImageScale: Swift.Float) -> Mocap4Face.FaceTrackerReprojectorResult
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FaceTrackerReprojectorResult : Mocap4Face.ConvertibleToKotlin {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ spatialPosition: Mocap4Face.Vec3, _ spatialScale: Swift.Float)
  public var spatialPosition: Mocap4Face.Vec3 {
    get
  }
  public var spatialScale: Swift.Float {
    get
  }
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func description() -> Swift.String
  public func component1() -> Mocap4Face.Vec3
  public func component2() -> Swift.Float
  public func doCopy(_ spatialPosition: Mocap4Face.Vec3, _ spatialScale: Swift.Float) -> Mocap4Face.FaceTrackerReprojectorResult
  public static func == (lhs: Mocap4Face.FaceTrackerReprojectorResult, rhs: Mocap4Face.FaceTrackerReprojectorResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FaceTrackerReprojectors : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public static func fixedZReprojector(_ fovDegrees: Swift.Float, _ widthToHeight: Swift.Float, _ avatarWidth: Swift.Float, _ z: Swift.Float) -> Mocap4Face.FaceTrackerReprojector
  public static func fixedZReprojector(_ fovDegrees: Swift.Float, _ renderingWidth: Swift.Int, _ renderingHeight: Swift.Int, _ imageWidth: Swift.Int, _ imageHeight: Swift.Int, _ fillMode: Mocap4Face.FillMode, _ avatarWidth: Swift.Float, _ z: Swift.Float) -> Mocap4Face.FaceTrackerReprojector
  public static func fixedScaleReprojector(_ fovDegrees: Swift.Float, _ widthToHeight: Swift.Float, _ avatarWidth: Swift.Float, _ scale: Swift.Float) -> Mocap4Face.FaceTrackerReprojector
  public static func fixedScaleReprojector(_ fovDegrees: Swift.Float, _ renderingWidth: Swift.Int, _ renderingHeight: Swift.Int, _ imageWidth: Swift.Int, _ imageHeight: Swift.Int, _ fillMode: Mocap4Face.FillMode, _ avatarWidth: Swift.Float, _ scale: Swift.Float) -> Mocap4Face.FaceTrackerReprojector
  public static func == (lhs: Mocap4Face.FaceTrackerReprojectors, rhs: Mocap4Face.FaceTrackerReprojectors) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class NeuralNetOutput : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ outputs: [Swift.String : Mocap4Face.KotlinFloatArray], _ debugInput: Mocap4Face.TrackerImage? = nil)
  public var outputs: [Swift.String : Mocap4Face.KotlinFloatArray] {
    get
  }
  public var debugInput: Mocap4Face.TrackerImage? {
    get
  }
  public static func == (lhs: Mocap4Face.NeuralNetOutput, rhs: Mocap4Face.NeuralNetOutput) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class TrackerNetResult : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ blendshapes: [Swift.String : Swift.Float], _ transforms: Mocap4Face.KotlinFloatArray, _ isFace: Swift.Float)
  public var blendshapes: [Swift.String : Swift.Float] {
    get
  }
  public var transforms: Mocap4Face.KotlinFloatArray {
    get
  }
  public var isFace: Swift.Float {
    get
  }
  public static func == (lhs: Mocap4Face.TrackerNetResult, rhs: Mocap4Face.TrackerNetResult) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Rect : Mocap4Face.Vector {
  public typealias T = Mocap4Face.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ x: Swift.Float, _ y: Swift.Float, _ width: Swift.Float, _ height: Swift.Float)
  convenience public init(_ origin: Mocap4Face.Vec2, _ size: Mocap4Face.Vec2)
  convenience public init()
  public var x: Swift.Float {
    get
  }
  public var y: Swift.Float {
    get
  }
  public var width: Swift.Float {
    get
  }
  public var height: Swift.Float {
    get
  }
  public var origin: Mocap4Face.Vec2 {
    get
  }
  public var extent: Mocap4Face.Vec2 {
    get
  }
  public var minX: Swift.Float {
    get
  }
  public var minY: Swift.Float {
    get
  }
  public var maxX: Swift.Float {
    get
  }
  public var maxY: Swift.Float {
    get
  }
  public static var FULL: Mocap4Face.Rect {
    get
  }
  public func area() -> Swift.Float
  public func expandToSquare() -> Mocap4Face.Rect
  public func scaleWidthHeight(_ sw: Swift.Float, _ sh: Swift.Float) -> Mocap4Face.Rect
  public func scaleXY(_ sx: Swift.Float, _ sy: Swift.Float) -> Mocap4Face.Rect
  public func offset(_ dx: Swift.Float, _ dy: Swift.Float) -> Mocap4Face.Rect
  public func flipY(_ maxHeight: Swift.Float = 1.n) -> Mocap4Face.Rect
  public func toArray() -> Mocap4Face.KotlinFloatArray
  public func toFloatArray() -> Mocap4Face.KotlinFloatArray
  public func insetBy(_ dx: Swift.Float, _ dy: Swift.Float) -> Mocap4Face.Rect
  public static func == (lhs: Mocap4Face.Rect, rhs: Mocap4Face.Rect) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class RectBuilder : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ base: Mocap4Face.Rect)
  convenience public init(_ x: Swift.Float, _ y: Swift.Float, _ width: Swift.Float, _ height: Swift.Float)
  public var x: Swift.Float {
    get
    set(newValue)
  }
  public var y: Swift.Float {
    get
    set(newValue)
  }
  public var width: Swift.Float {
    get
    set(newValue)
  }
  public var height: Swift.Float {
    get
    set(newValue)
  }
  public var origin: Mocap4Face.Vec2 {
    get
  }
  public var extent: Mocap4Face.Vec2 {
    get
  }
  public func build() -> Mocap4Face.Rect
  public static func == (lhs: Mocap4Face.RectBuilder, rhs: Mocap4Face.RectBuilder) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class CoreMLModel : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var inputWidth: Swift.Int {
    get
  }
  public var inputHeight: Swift.Int {
    get
  }
  public var inputChannels: Swift.Int {
    get
  }
  public var metadata: [Swift.String : Swift.String] {
    get
  }
  public func run(_ image: Mocap4Face.TrackerImage, _ rect: Mocap4Face.Rect) -> Mocap4Face.Try<Mocap4Face.NeuralNetOutput>
  public static func create(_ fileSystem: Mocap4Face.FileSystem, _ modelName: Swift.String, _ context: Mocap4Face.TrackerGPUContext) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.CoreMLModel>>
  public static func == (lhs: Mocap4Face.CoreMLModel, rhs: Mocap4Face.CoreMLModel) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol File {
  var _wrappedFile: Swift.AnyObject { get }
  var path: Mocap4Face.Path { get }
  var fileSystem: Mocap4Face.FileSystem { get }
  func readAllBytes() -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.KotlinByteArray>>
  func readAllText() -> Mocap4Face.Future<Mocap4Face.Try<Swift.String>>
  func readImage() -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.Image>>
}
@_hasMissingDesignatedInitializers public class FileWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.File {
  public var _wrappedFile: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var path: Mocap4Face.Path {
    get
  }
  public var fileSystem: Mocap4Face.FileSystem {
    get
  }
  public func readAllBytes() -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.KotlinByteArray>>
  public func readAllText() -> Mocap4Face.Future<Mocap4Face.Try<Swift.String>>
  public func readImage() -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.Image>>
  @objc deinit
}
public protocol FileSystem {
  var _wrappedFileSystem: Swift.AnyObject { get }
  var root: Mocap4Face.Path { get }
  func fileAt(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.File>>
  func watch(_ path: Mocap4Face.Path) -> Mocap4Face.Observable<Mocap4Face.Try<Mocap4Face.File>>
  func exists(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Swift.Bool>
  func lastModified(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Int64>>
}
@_hasMissingDesignatedInitializers public class FileSystemWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var root: Mocap4Face.Path {
    get
  }
  public func fileAt(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.File>>
  public func watch(_ path: Mocap4Face.Path) -> Mocap4Face.Observable<Mocap4Face.Try<Mocap4Face.File>>
  public func exists(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Swift.Bool>
  public func lastModified(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Int64>>
  @objc deinit
}
public protocol WriteableFileSystem : Mocap4Face.FileSystem {
  var _wrappedWriteableFileSystem: Swift.AnyObject { get }
  func writeFile(_ path: Mocap4Face.Path, _ bytes: Mocap4Face.KotlinByteArray, _ lastModified: Swift.Int64?) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Void>>
}
@_hasMissingDesignatedInitializers public class WriteableFileSystemWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.WriteableFileSystem {
  public var _wrappedWriteableFileSystem: Swift.AnyObject {
    get
  }
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var root: Mocap4Face.Path {
    get
  }
  public func writeFile(_ path: Mocap4Face.Path, _ bytes: Mocap4Face.KotlinByteArray, _ lastModified: Swift.Int64? = nil) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Void>>
  public func fileAt(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.File>>
  public func watch(_ path: Mocap4Face.Path) -> Mocap4Face.Observable<Mocap4Face.Try<Mocap4Face.File>>
  public func exists(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Swift.Bool>
  public func lastModified(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Int64>>
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ApplicationContext : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ bundle: Foundation.Bundle = defaultBundle())
  public var bundle: Foundation.Bundle {
    get
  }
  public static func == (lhs: Mocap4Face.ApplicationContext, rhs: Mocap4Face.ApplicationContext) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class ResourceFileSystem : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  convenience public init(_ context: Mocap4Face.ApplicationContext, _ root: Mocap4Face.Path)
  public var root: Mocap4Face.Path {
    get
  }
  public func fileAt(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.File>>
  public func watch(_ path: Mocap4Face.Path) -> Mocap4Face.Observable<Mocap4Face.Try<Mocap4Face.File>>
  public func exists(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Swift.Bool>
  public func lastModified(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Int64>>
  public static func create(_ context: Mocap4Face.ApplicationContext) -> Mocap4Face.ResourceFileSystem
  public static func create(_ context: Mocap4Face.ApplicationContext, _ root: Mocap4Face.Path) -> Mocap4Face.ResourceFileSystem
  public static func == (lhs: Mocap4Face.ResourceFileSystem, rhs: Mocap4Face.ResourceFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DeviceFileSystem : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.WriteableFileSystem {
  public var _wrappedWriteableFileSystem: Swift.AnyObject {
    get
  }
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ root: Mocap4Face.Path)
  public var root: Mocap4Face.Path {
    get
  }
  public func fileAt(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.File>>
  public func watch(_ path: Mocap4Face.Path) -> Mocap4Face.Observable<Mocap4Face.Try<Mocap4Face.File>>
  public func exists(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Swift.Bool>
  public func lastModified(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Int64>>
  public func writeFile(_ path: Mocap4Face.Path, _ bytes: Mocap4Face.KotlinByteArray, _ lastModified: Swift.Int64? = nil) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Void>>
  public static func create(_ root: Mocap4Face.Path) -> Mocap4Face.DeviceFileSystem
  public static func == (lhs: Mocap4Face.DeviceFileSystem, rhs: Mocap4Face.DeviceFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class NetworkFileSystem : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ serverUrl: Swift.String, _ disableCache: Swift.Bool, _ root: Mocap4Face.Path)
  public var session: Foundation.URLSession {
    get
  }
  public var root: Mocap4Face.Path {
    get
  }
  public func fileAt(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.File>>
  public func watch(_ path: Mocap4Face.Path) -> Mocap4Face.Observable<Mocap4Face.Try<Mocap4Face.File>>
  public func exists(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Swift.Bool>
  public func lastModified(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Int64>>
  public static func create(_ serverUrl: Swift.String) -> Mocap4Face.NetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ disableCache: Swift.Bool) -> Mocap4Face.NetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ root: Mocap4Face.Path) -> Mocap4Face.NetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ disableCache: Swift.Bool, _ root: Mocap4Face.Path) -> Mocap4Face.NetworkFileSystem
  public static func == (lhs: Mocap4Face.NetworkFileSystem, rhs: Mocap4Face.NetworkFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class WriteableNetworkFileSystem : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.FileSystem, Mocap4Face.WriteableFileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  public var _wrappedWriteableFileSystem: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ serverUrl: Swift.String, _ disableCache: Swift.Bool, _ root: Mocap4Face.Path)
  public var root: Mocap4Face.Path {
    get
  }
  public func writeFile(_ path: Mocap4Face.Path, _ bytes: Mocap4Face.KotlinByteArray, _ lastModified: Swift.Int64? = nil) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Void>>
  public func fileAt(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.File>>
  public func watch(_ path: Mocap4Face.Path) -> Mocap4Face.Observable<Mocap4Face.Try<Mocap4Face.File>>
  public func watch(_ watchPaths: Swift.Set<Swift.String>) -> Mocap4Face.Future<Swift.Set<Swift.String>>
  public func exists(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Swift.Bool>
  public func lastModified(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Int64>>
  public static func create(_ serverUrl: Swift.String) -> Mocap4Face.WriteableNetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ disableCache: Swift.Bool) -> Mocap4Face.WriteableNetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ root: Mocap4Face.Path) -> Mocap4Face.WriteableNetworkFileSystem
  public static func create(_ serverUrl: Swift.String, _ disableCache: Swift.Bool, _ root: Mocap4Face.Path) -> Mocap4Face.WriteableNetworkFileSystem
  public static func == (lhs: Mocap4Face.WriteableNetworkFileSystem, rhs: Mocap4Face.WriteableNetworkFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FileSubSystem<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.FileSystem where T : Mocap4Face.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ parent: T, _ newRoot: Mocap4Face.Path)
  public var root: Mocap4Face.Path {
    get
  }
  public var parent: T {
    get
  }
  public var newRoot: Mocap4Face.Path {
    get
  }
  public func fileAt(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.File>>
  public func watch(_ path: Mocap4Face.Path) -> Mocap4Face.Observable<Mocap4Face.Try<Mocap4Face.File>>
  public func exists(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Swift.Bool>
  public func lastModified(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Int64>>
  public static func == (lhs: Mocap4Face.FileSubSystem<T>, rhs: Mocap4Face.FileSubSystem<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class WriteableFileSubSystem : Mocap4Face.FileSubSystem<Mocap4Face.WriteableFileSystemWrapper>, Mocap4Face.WriteableFileSystem {
  public var _wrappedWriteableFileSystem: Swift.AnyObject {
    get
  }
  override public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ parent: Mocap4Face.WriteableFileSystem, _ newRoot: Mocap4Face.Path)
  public func writeFile(_ path: Mocap4Face.Path, _ bytes: Mocap4Face.KotlinByteArray, _ lastModified: Swift.Int64? = nil) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Void>>
  public static func == (lhs: Mocap4Face.WriteableFileSubSystem, rhs: Mocap4Face.WriteableFileSubSystem) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FallbackFileSystem : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ filesystems: Mocap4Face.KotlinArray<Mocap4Face.FileSystem>)
  convenience public init(_ filesystems_: [Mocap4Face.FileSystem])
  public var root: Mocap4Face.Path {
    get
  }
  public func fileAt(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.File>>
  public func watch(_ path: Mocap4Face.Path) -> Mocap4Face.Observable<Mocap4Face.Try<Mocap4Face.File>>
  public func exists(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Swift.Bool>
  public func lastModified(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Int64>>
  public static func == (lhs: Mocap4Face.FallbackFileSystem, rhs: Mocap4Face.FallbackFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class IndexedFileSystem<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.FileSystem where T : Mocap4Face.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ baseFileSystem: T, _ indexReloadIntervalMs: Swift.Int = 60 * 60 * 1000)
  public var baseFileSystem: T {
    get
  }
  public var root: Mocap4Face.Path {
    get
  }
  public func lastModified(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Int64>>
  public func fileAt(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.File>>
  public func watch(_ path: Mocap4Face.Path) -> Mocap4Face.Observable<Mocap4Face.Try<Mocap4Face.File>>
  public func exists(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Swift.Bool>
  public static func == (lhs: Mocap4Face.IndexedFileSystem<T>, rhs: Mocap4Face.IndexedFileSystem<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class IndexedWriteableFileSystem : Mocap4Face.IndexedFileSystem<Mocap4Face.WriteableFileSystemWrapper>, Mocap4Face.WriteableFileSystem {
  public var _wrappedWriteableFileSystem: Swift.AnyObject {
    get
  }
  override public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ baseFileSystem: Mocap4Face.WriteableFileSystem, _ indexReloadIntervalMs: Swift.Int = 60 * 60 * 1000)
  public func writeFile(_ path: Mocap4Face.Path, _ bytes: Mocap4Face.KotlinByteArray, _ lastModified: Swift.Int64? = nil) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Void>>
  public static func == (lhs: Mocap4Face.IndexedWriteableFileSystem, rhs: Mocap4Face.IndexedWriteableFileSystem) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class CachingFileSystem : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ baseFileSystem: Mocap4Face.FileSystem, _ cachingFileSystem: Mocap4Face.WriteableFileSystem, _ updateCheckInterval: Swift.Int64 = 60 * 60 * 1000)
  public var root: Mocap4Face.Path {
    get
  }
  public func fileAt(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.File>>
  public func watch(_ path: Mocap4Face.Path) -> Mocap4Face.Observable<Mocap4Face.Try<Mocap4Face.File>>
  public func exists(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Swift.Bool>
  public func lastModified(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Int64>>
  public static func == (lhs: Mocap4Face.CachingFileSystem, rhs: Mocap4Face.CachingFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DateCompareFileSystem : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ firstFs: Mocap4Face.FileSystem, _ secondFs: Mocap4Face.FileSystem)
  public var root: Mocap4Face.Path {
    get
  }
  public func fileAt(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.File>>
  public func watch(_ path: Mocap4Face.Path) -> Mocap4Face.Observable<Mocap4Face.Try<Mocap4Face.File>>
  public func exists(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Swift.Bool>
  public func lastModified(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Int64>>
  public static func == (lhs: Mocap4Face.DateCompareFileSystem, rhs: Mocap4Face.DateCompareFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class UptodateFileSystem : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.FileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ serverUrl: Swift.String, _ context: Mocap4Face.ApplicationContext)
  public var root: Mocap4Face.Path {
    get
  }
  public func fileAt(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.File>>
  public func watch(_ path: Mocap4Face.Path) -> Mocap4Face.Observable<Mocap4Face.Try<Mocap4Face.File>>
  public func exists(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Swift.Bool>
  public func lastModified(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Int64>>
  public static func == (lhs: Mocap4Face.UptodateFileSystem, rhs: Mocap4Face.UptodateFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DevelopmentFileSystem : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.FileSystem, Mocap4Face.WriteableFileSystem {
  public var _wrappedFileSystem: Swift.AnyObject {
    get
  }
  public var _wrappedWriteableFileSystem: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ root: Mocap4Face.Path, _ resourceDirsOverride: [Swift.String], _ port: Swift.String = "8000")
  convenience public init(_ root: Mocap4Face.Path = Path(""), _ resourceDirsOverride: Mocap4Face.KotlinArray<Swift.String>? = nil, _ port_: Swift.String = "8000")
  public var root: Mocap4Face.Path {
    get
  }
  public func writeFile(_ path: Mocap4Face.Path, _ bytes: Mocap4Face.KotlinByteArray, _ lastModified: Swift.Int64? = nil) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Void>>
  public func fileAt(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.File>>
  public func watch(_ path: Mocap4Face.Path) -> Mocap4Face.Observable<Mocap4Face.Try<Mocap4Face.File>>
  public func watch(_ watchPaths: Swift.Set<Swift.String>) -> Mocap4Face.Future<Swift.Set<Swift.String>>
  public func exists(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Swift.Bool>
  public func lastModified(_ path: Mocap4Face.Path) -> Mocap4Face.Future<Mocap4Face.Try<Swift.Int64>>
  public static func == (lhs: Mocap4Face.DevelopmentFileSystem, rhs: Mocap4Face.DevelopmentFileSystem) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol FileSystemWatch {
  var _wrappedFileSystemWatch: Swift.AnyObject { get }
  var changed: Swift.Bool { get }
  func watch<T>(_ noChangeValue: T, _ watcher: @escaping (Mocap4Face.FileSystem) -> T) -> Mocap4Face.KotlinPair<Mocap4Face.FileSystemWatch, T>
  func watch<T>(_ noChangeValue: T, _ fileSystem: Mocap4Face.FileSystem, _ watcher: @escaping (Mocap4Face.FileSystem) -> T) -> Mocap4Face.KotlinPair<Mocap4Face.FileSystemWatch, T>
  func watchFlat<T>(_ noChangeValue: T, _ watcher: @escaping (Mocap4Face.FileSystem) -> Mocap4Face.Future<T>) -> Mocap4Face.Future<Mocap4Face.KotlinPair<Mocap4Face.FileSystemWatch, T>>
}
@_hasMissingDesignatedInitializers public class FileSystemWatchWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.FileSystemWatch {
  public var _wrappedFileSystemWatch: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var changed: Swift.Bool {
    get
  }
  public func watch<T>(_ noChangeValue: T, _ watcher: @escaping (Mocap4Face.FileSystem) -> T) -> Mocap4Face.KotlinPair<Mocap4Face.FileSystemWatch, T>
  public func watch<T>(_ noChangeValue: T, _ fileSystem: Mocap4Face.FileSystem, _ watcher: @escaping (Mocap4Face.FileSystem) -> T) -> Mocap4Face.KotlinPair<Mocap4Face.FileSystemWatch, T>
  public func watchFlat<T>(_ noChangeValue: T, _ watcher: @escaping (Mocap4Face.FileSystem) -> Mocap4Face.Future<T>) -> Mocap4Face.Future<Mocap4Face.KotlinPair<Mocap4Face.FileSystemWatch, T>>
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FileSystemWatchGeneral : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.FileSystemWatch {
  public var _wrappedFileSystemWatch: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ fileSystem: Mocap4Face.FileSystem, _ watchFilter: ((Swift.String) -> Swift.Bool)? = nil, _ errorSensitivity: Mocap4Face.FileWatchErrorSensitivity = .medium)
  public var fileSystem: Mocap4Face.FileSystem {
    get
  }
  public var changed: Swift.Bool {
    get
  }
  public func watch<T>(_ noChangeValue: T, _ watcher: @escaping (Mocap4Face.FileSystem) -> T) -> Mocap4Face.KotlinPair<Mocap4Face.FileSystemWatch, T>
  public func watch<T>(_ noChangeValue: T, _ fileSystem: Mocap4Face.FileSystem, _ watcher: @escaping (Mocap4Face.FileSystem) -> T) -> Mocap4Face.KotlinPair<Mocap4Face.FileSystemWatch, T>
  public func watchFlat<T>(_ noChangeValue: T, _ watcher: @escaping (Mocap4Face.FileSystem) -> Mocap4Face.Future<T>) -> Mocap4Face.Future<Mocap4Face.KotlinPair<Mocap4Face.FileSystemWatch, T>>
  public func watchFlat<T>(_ noChangeValue: T, _ fileSystem: Mocap4Face.FileSystem, _ watcher: @escaping (Mocap4Face.FileSystem) -> Mocap4Face.Future<T>) -> Mocap4Face.Future<Mocap4Face.KotlinPair<Mocap4Face.FileSystemWatch, T>>
  public static func == (lhs: Mocap4Face.FileSystemWatchGeneral, rhs: Mocap4Face.FileSystemWatchGeneral) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FileSystemWatcher : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ fileSystem: Mocap4Face.FileSystem, _ watchFilter: ((Swift.String) -> Swift.Bool)? = nil, _ errorSensitivity: Mocap4Face.FileWatchErrorSensitivity = .medium)
  public func watch<T>(_ noChangeValue: T, _ watcher: @escaping (Mocap4Face.FileSystem) -> T) -> T
  public func watch<T>(_ noChangeValue: T, _ fileSystem: Mocap4Face.FileSystem, _ watcher: @escaping (Mocap4Face.FileSystem) -> T) -> T
  public func watchFlat<T>(_ noChangeValue: T, _ watcher: @escaping (Mocap4Face.FileSystem) -> Mocap4Face.Future<T>) -> Mocap4Face.Future<T>
  public static func == (lhs: Mocap4Face.FileSystemWatcher, rhs: Mocap4Face.FileSystemWatcher) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public enum FileWatchErrorSensitivity : Swift.CustomStringConvertible, Mocap4Face.ConvertibleToKotlin, Swift.CustomDebugStringConvertible {
  case low
  case medium
  case high
  public var ordinal: Swift.Int {
    get
  }
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
  public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public static func == (a: Mocap4Face.FileWatchErrorSensitivity, b: Mocap4Face.FileWatchErrorSensitivity) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FileWatchAsync : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ file: Mocap4Face.File, _ errorSensitivity: Mocap4Face.FileWatchErrorSensitivity = .medium, _ watchContents: Swift.Bool = false)
  convenience public init(_ path: Mocap4Face.Path, _ fileSystem: Mocap4Face.FileSystem, _ file: Mocap4Face.File, _ errorSensitivity: Mocap4Face.FileWatchErrorSensitivity = .medium, _ watchContents: Swift.Bool = false)
  convenience public init(_ path: Mocap4Face.Path, _ fileSystem: Mocap4Face.FileSystem, _ errorSensitivity: Mocap4Face.FileWatchErrorSensitivity = .medium, _ watchContents: Swift.Bool = false)
  public var path: Mocap4Face.Path {
    get
  }
  public var changed: Swift.Bool {
    get
  }
  public var fileSystem: Mocap4Face.FileSystem {
    get
  }
  public func getFile() -> Mocap4Face.Try<Mocap4Face.File>
  public func watch(_ fileSystem: Mocap4Face.FileSystem) -> Mocap4Face.Future<Mocap4Face.FileWatchAsync>
  public static func == (lhs: Mocap4Face.FileWatchAsync, rhs: Mocap4Face.FileWatchAsync) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FileWatch : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ file: Mocap4Face.File, _ errorSensitivity: Mocap4Face.FileWatchErrorSensitivity = .medium, _ watchContents: Swift.Bool = false)
  convenience public init(_ path: Mocap4Face.Path, _ fileSystem: Mocap4Face.FileSystem, _ file: Mocap4Face.File, _ errorSensitivity: Mocap4Face.FileWatchErrorSensitivity = .medium, _ watchContents: Swift.Bool = false)
  convenience public init(_ path: Mocap4Face.Path, _ fileSystem: Mocap4Face.FileSystem, _ errorSensitivity: Mocap4Face.FileWatchErrorSensitivity = .medium, _ watchContents: Swift.Bool = false)
  public var path: Mocap4Face.Path {
    get
  }
  public var changed: Swift.Bool {
    get
  }
  public var fileSystem: Mocap4Face.FileSystem {
    get
  }
  public func getFile() -> Mocap4Face.Try<Mocap4Face.File>
  public func watch(_ fileSystem: Mocap4Face.FileSystem) -> Mocap4Face.FileWatch
  public static func == (lhs: Mocap4Face.FileWatch, rhs: Mocap4Face.FileWatch) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FileWatcher : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ file: Mocap4Face.File, _ errorSensitivity: Mocap4Face.FileWatchErrorSensitivity = .medium)
  convenience public init(_ path: Mocap4Face.Path, _ fileSystem: Mocap4Face.FileSystem, _ errorSensitivity: Mocap4Face.FileWatchErrorSensitivity = .medium)
  public func watch<T>(_ noChangeValue: T, _ fileSystem: Mocap4Face.FileSystem, _ watcher: @escaping (Mocap4Face.Try<Mocap4Face.File>) -> T) -> T
  public func watch(_ fileSystem: Mocap4Face.FileSystem) -> Mocap4Face.Try<Mocap4Face.File>?
  public static func == (lhs: Mocap4Face.FileWatcher, rhs: Mocap4Face.FileWatcher) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Path : Mocap4Face.ConvertibleToKotlin {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ path: Swift.String)
  public func lastComponent() -> Swift.String
  public func `extension`() -> Swift.String
  public func baseName() -> Swift.String
  public func directory() -> Mocap4Face.Path
  public func join(_ path: Swift.String) -> Mocap4Face.Path
  public func join(_ path_: Mocap4Face.Path) -> Mocap4Face.Path
  public func div(_ path: Swift.String) -> Mocap4Face.Path
  public func div(_ path_: Mocap4Face.Path) -> Mocap4Face.Path
  public func normalized() -> Mocap4Face.Path
  public func description() -> Swift.String
  public func isEqual(_ other: Any?) -> Swift.Bool
  public func hash() -> Swift.UInt
  public func doCopy(_ path: Swift.String) -> Mocap4Face.Path
  public static func == (lhs: Mocap4Face.Path, rhs: Mocap4Face.Path) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol FileWithURL : Mocap4Face.File {
  var _wrappedFileWithURL: Swift.AnyObject { get }
  func obtainLocalUrl() -> Mocap4Face.Try<Foundation.URL>
}
@_hasMissingDesignatedInitializers public class FileWithURLWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.FileWithURL {
  public var _wrappedFileWithURL: Swift.AnyObject {
    get
  }
  public var _wrappedFile: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var path: Mocap4Face.Path {
    get
  }
  public var fileSystem: Mocap4Face.FileSystem {
    get
  }
  public func obtainLocalUrl() -> Mocap4Face.Try<Foundation.URL>
  public func readAllBytes() -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.KotlinByteArray>>
  public func readAllText() -> Mocap4Face.Future<Mocap4Face.Try<Swift.String>>
  public func readImage() -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.Image>>
  @objc deinit
}
@_hasMissingDesignatedInitializers public class IOSFile : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.FileWithURL {
  public var _wrappedFileWithURL: Swift.AnyObject {
    get
  }
  public var _wrappedFile: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ absolutePath: Mocap4Face.Path, _ path: Mocap4Face.Path, _ fileSystem: Mocap4Face.FileSystem)
  public var path: Mocap4Face.Path {
    get
  }
  public var fileSystem: Mocap4Face.FileSystem {
    get
  }
  public func obtainLocalUrl() -> Mocap4Face.Try<Foundation.URL>
  public func readAllBytes() -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.KotlinByteArray>>
  public func readAllText() -> Mocap4Face.Future<Mocap4Face.Try<Swift.String>>
  public func readImage() -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.Image>>
  public static func == (lhs: Mocap4Face.IOSFile, rhs: Mocap4Face.IOSFile) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class NSDataFile : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.FileWithURL {
  public var _wrappedFileWithURL: Swift.AnyObject {
    get
  }
  public var _wrappedFile: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ data: Foundation.Data, _ path: Mocap4Face.Path, _ fileSystem: Mocap4Face.FileSystem)
  public var path: Mocap4Face.Path {
    get
  }
  public var fileSystem: Mocap4Face.FileSystem {
    get
  }
  public func readAllBytes() -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.KotlinByteArray>>
  public func obtainLocalUrl() -> Mocap4Face.Try<Foundation.URL>
  public func readAllText() -> Mocap4Face.Future<Mocap4Face.Try<Swift.String>>
  public func readImage() -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.Image>>
  public func description() -> Swift.String
  public static func == (lhs: Mocap4Face.NSDataFile, rhs: Mocap4Face.NSDataFile) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class SocketReader : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func readLine() -> Swift.String
  public static func == (lhs: Mocap4Face.SocketReader, rhs: Mocap4Face.SocketReader) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol Cache {
  associatedtype K
  associatedtype T
  var _wrappedCache: Swift.AnyObject { get }
  var size: Swift.Int { get }
  func pop(_ key: Self.K) -> Self.T?
  func push(_ key: Self.K, _ value: Self.T) -> Mocap4Face.KotlinPair<Self.K, Self.T?>?
  func set(_ key: Self.K, _ value: Self.T)
  func get(_ key: Self.K, _ default: @escaping () -> Self.T) -> Self.T
  func get(_ key: Self.K, _ default: @escaping () -> Self.T, _ removedConsumer: @escaping (Mocap4Face.KotlinPair<Self.K, Self.T?>) -> Swift.Void) -> Self.T
  func get(_ key: Self.K) -> Self.T?
}
@_hasMissingDesignatedInitializers public class CacheWrapper<K, T> : Mocap4Face.ConvertibleToKotlin, Mocap4Face.Cache {
  public typealias K = K
  public typealias T = T
  public var _wrappedCache: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var size: Swift.Int {
    get
  }
  public func pop(_ key: K) -> T?
  public func push(_ key: K, _ value: T) -> Mocap4Face.KotlinPair<K, T?>?
  public func set(_ key: K, _ value: T)
  public func get(_ key: K, _ default: @escaping () -> T) -> T
  public func get(_ key: K, _ default: @escaping () -> T, _ removedConsumer: @escaping (Mocap4Face.KotlinPair<K, T?>) -> Swift.Void) -> T
  public func get(_ key: K) -> T?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class LinkedMapCache<K, T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.Cache {
  public typealias K = K
  public typealias T = T
  public var _wrappedCache: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ capacity: Swift.Int)
  public var size: Swift.Int {
    get
  }
  public func pop(_ key: K) -> T?
  public func push(_ key: K, _ value: T) -> Mocap4Face.KotlinPair<K, T?>?
  public func get(_ key: K, _ default: @escaping () -> T) -> T
  public func get(_ key: K, _ default: @escaping () -> T, _ removedConsumer: @escaping (Mocap4Face.KotlinPair<K, T?>) -> Swift.Void) -> T
  public func get(_ key: K) -> T?
  public func set(_ key: K, _ value: T)
  public static func == (lhs: Mocap4Face.LinkedMapCache<K, T>, rhs: Mocap4Face.LinkedMapCache<K, T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class WeakCache<K, T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.Cache {
  public typealias K = K
  public typealias T = T
  public var _wrappedCache: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ capacity: Swift.Int)
  public var size: Swift.Int {
    get
  }
  public func pop(_ key: K) -> T?
  public func push(_ key: K, _ value: T) -> Mocap4Face.KotlinPair<K, T?>?
  public func get(_ key: K, _ default: @escaping () -> T) -> T
  public func get(_ key: K, _ default: @escaping () -> T, _ removedConsumer: @escaping (Mocap4Face.KotlinPair<K, T?>) -> Swift.Void) -> T
  public func get(_ key: K) -> T?
  public func set(_ key: K, _ value: T)
  public static func == (lhs: Mocap4Face.WeakCache<K, T>, rhs: Mocap4Face.WeakCache<K, T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class StrongWeakCache<K, T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.Cache {
  public typealias K = K
  public typealias T = T
  public var _wrappedCache: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ strongCapacity: Swift.Int, _ weakCapacity: Swift.Int)
  public var size: Swift.Int {
    get
  }
  public func pop(_ key: K) -> T?
  public func push(_ key: K, _ value: T) -> Mocap4Face.KotlinPair<K, T?>?
  public func get(_ key: K, _ default: @escaping () -> T) -> T
  public func get(_ key: K, _ default: @escaping () -> T, _ removedConsumer: @escaping (Mocap4Face.KotlinPair<K, T?>) -> Swift.Void) -> T
  public func get(_ key: K) -> T?
  public func set(_ key: K, _ value: T)
  public static func == (lhs: Mocap4Face.StrongWeakCache<K, T>, rhs: Mocap4Face.StrongWeakCache<K, T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class SynchronizedCache<K, T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.Cache {
  public typealias K = K
  public typealias T = T
  public var _wrappedCache: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init<TCache>(_ cacheProducer: @escaping () -> TCache) where K == TCache.K, T == TCache.T, TCache : Mocap4Face.Cache
  public var size: Swift.Int {
    get
  }
  public func pop(_ key: K) -> T?
  public func push(_ key: K, _ value: T) -> Mocap4Face.KotlinPair<K, T?>?
  public func get(_ key: K, _ default: @escaping () -> T) -> T
  public func get(_ key: K, _ default: @escaping () -> T, _ removedConsumer: @escaping (Mocap4Face.KotlinPair<K, T?>) -> Swift.Void) -> T
  public func get(_ key: K) -> T?
  public func set(_ key: K, _ value: T)
  public static func == (lhs: Mocap4Face.SynchronizedCache<K, T>, rhs: Mocap4Face.SynchronizedCache<K, T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class StrictSynchronizedCache<K, T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.Cache {
  public typealias K = K
  public typealias T = T
  public var _wrappedCache: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init<TCache>(_ cacheProducer: @escaping () -> TCache) where K == TCache.K, T == TCache.T, TCache : Mocap4Face.Cache
  public var size: Swift.Int {
    get
  }
  public func pop(_ key: K) -> T?
  public func push(_ key: K, _ value: T) -> Mocap4Face.KotlinPair<K, T?>?
  public func get(_ key: K, _ default: @escaping () -> T) -> T
  public func get(_ key: K, _ default: @escaping () -> T, _ removedConsumer: @escaping (Mocap4Face.KotlinPair<K, T?>) -> Swift.Void) -> T
  public func get(_ key: K) -> T?
  public func set(_ key: K, _ value: T)
  public static func == (lhs: Mocap4Face.StrictSynchronizedCache<K, T>, rhs: Mocap4Face.StrictSynchronizedCache<K, T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class DummyCache<K, T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.Cache {
  public typealias K = K
  public typealias T = T
  public var _wrappedCache: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public var size: Swift.Int {
    get
  }
  public func pop(_ key: K) -> T?
  public func push(_ key: K, _ value: T) -> Mocap4Face.KotlinPair<K, T?>?
  public func get(_ key: K, _ default: @escaping () -> T) -> T
  public func get(_ key: K, _ default: @escaping () -> T, _ removedConsumer: @escaping (Mocap4Face.KotlinPair<K, T?>) -> Swift.Void) -> T
  public func get(_ key: K) -> T?
  public func set(_ key: K, _ value: T)
  public static func == (lhs: Mocap4Face.DummyCache<K, T>, rhs: Mocap4Face.DummyCache<K, T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Once<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func get(_ producer: @escaping () -> T) -> T
  public static func == (lhs: Mocap4Face.Once<T>, rhs: Mocap4Face.Once<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class OnceSynchronized<T> : Mocap4Face.Once<T> {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public static func == (lhs: Mocap4Face.OnceSynchronized<T>, rhs: Mocap4Face.OnceSynchronized<T>) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class FinalizationRegistry : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ finalizationIntervalMs: Swift.Int = 500)
  public func register(_ ref: Any, _ finalizer: @escaping () -> Swift.Void)
  public static func == (lhs: Mocap4Face.FinalizationRegistry, rhs: Mocap4Face.FinalizationRegistry) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FinalizeClass : Mocap4Face.FinalizationRegistry {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  public static func == (lhs: Mocap4Face.FinalizeClass, rhs: Mocap4Face.FinalizeClass) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
public let Finalize: Mocap4Face.FinalizeClass
@_hasMissingDesignatedInitializers public class Timer : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var elapsed: Swift.Double {
    get
  }
  public func tick() -> Mocap4Face.Timer
  public static func start() -> Mocap4Face.Timer
  public static func == (lhs: Mocap4Face.Timer, rhs: Mocap4Face.Timer) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class FPS : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ interval: Swift.Double)
  public func tick(_ consumer: ((Swift.Double) -> Swift.Void)?) -> Swift.Double
  public static func == (lhs: Mocap4Face.FPS, rhs: Mocap4Face.FPS) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Ticker : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ interval: Swift.Double)
  public func tick<T, TTickerMapper>(_ value: T, _ mapper: TTickerMapper) -> T where T == TTickerMapper.T, TTickerMapper : Mocap4Face.TickerMapper
  public func tick<T>(_ value: T, _ mapper_: @escaping (T) -> T) -> T
  public static func == (lhs: Mocap4Face.Ticker, rhs: Mocap4Face.Ticker) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol TickerMapper {
  associatedtype T
  var _wrappedTickerMapper: Swift.AnyObject { get }
  func invoke(_ value: Self.T, _ tickCount: Swift.Int, _ elapsed: Swift.Double) -> Self.T
}
@_hasMissingDesignatedInitializers public class TickerMapperWrapper<T> : Mocap4Face.ConvertibleToKotlin, Mocap4Face.TickerMapper {
  public typealias T = T
  public var _wrappedTickerMapper: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func invoke(_ value: T, _ tickCount: Swift.Int, _ elapsed: Swift.Double) -> T
  @objc deinit
}
@_hasMissingDesignatedInitializers public class AbstractBlendshapes : Mocap4Face.Vector {
  public typealias T = Mocap4Face.AbstractBlendshapes
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ names: [Swift.String], _ elements: Mocap4Face.KotlinFloatArray)
  public var blendshapes: [Swift.String : Swift.Float] {
    get
  }
  public var names: [Swift.String] {
    get
  }
  public func factory(_ elements: Mocap4Face.KotlinFloatArray, _ names: [Swift.String]) -> Self
  public static func elements(_ names: [Swift.String], _ blendshapes: [Swift.String : Swift.Float], _ default: Swift.Float) -> Mocap4Face.KotlinFloatArray
  public static func elements(_ names: [Swift.String], _ indices: Any, _ weights: Any) -> Mocap4Face.KotlinFloatArray
  public static func == (lhs: Mocap4Face.AbstractBlendshapes, rhs: Mocap4Face.AbstractBlendshapes) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class CommonEmotionsClass : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var HAPPY: [Swift.String : Swift.Float] {
    get
  }
  public var SAD: [Swift.String : Swift.Float] {
    get
  }
  public var ANGRY: [Swift.String : Swift.Float] {
    get
  }
  public var VICIOUS: [Swift.String : Swift.Float] {
    get
  }
  public var SURPRISED: [Swift.String : Swift.Float] {
    get
  }
  public var SCARED: [Swift.String : Swift.Float] {
    get
  }
  public static func == (lhs: Mocap4Face.CommonEmotionsClass, rhs: Mocap4Face.CommonEmotionsClass) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public let CommonEmotions: Mocap4Face.CommonEmotionsClass
@_hasMissingDesignatedInitializers public class ExpressionBlendshapes : Mocap4Face.AbstractBlendshapes {
  public typealias T = Mocap4Face.Vector
  override public var _wrappedVec: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  override public func asKotlin() -> Swift.AnyObject
  convenience public init(_ blendshapes: [Swift.String : Swift.Float], _ default: Swift.Float = 0.n)
  public static func == (lhs: Mocap4Face.ExpressionBlendshapes, rhs: Mocap4Face.ExpressionBlendshapes) -> Swift.Bool
  override public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KotlinFloatArray : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ size: Swift.Int)
  convenience public init(_ size: Swift.Int, _ init: @escaping (Swift.Int) -> Swift.Float)
  public var size: Swift.Int {
    get
  }
  public var floatArray: Mocap4Face.KotlinFloatArray {
    get
  }
  public func get(_ index: Swift.Int) -> Swift.Float
  public func iterator() -> Mocap4Face.KotlinFloatIterator
  public func set(_ index: Swift.Int, _ value: Swift.Float)
  public static func == (lhs: Mocap4Face.KotlinFloatArray, rhs: Mocap4Face.KotlinFloatArray) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinArray<T> : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ size: Swift.Int, _ init: @escaping (Swift.Int) -> T)
  public var size: Swift.Int {
    get
  }
  public func get(_ index: Swift.Int) -> T
  public func iterator<TKotlinIterator>() -> TKotlinIterator where T == TKotlinIterator.T, TKotlinIterator : Mocap4Face.KotlinIterator
  public func set(_ index: Swift.Int, _ value: T)
  public func flatten() -> Mocap4Face.KotlinFloatArray where T : Mocap4Face.KotlinFloatArray
  public static func == (lhs: Mocap4Face.KotlinArray<T>, rhs: Mocap4Face.KotlinArray<T>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinByteArray : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ size: Swift.Int)
  convenience public init(_ size: Swift.Int, _ init: @escaping (Swift.Int) -> Swift.CChar)
  public var size: Swift.Int {
    get
  }
  public func get(_ index: Swift.Int) -> Swift.Int8
  public func iterator() -> Mocap4Face.KotlinByteIterator
  public func set(_ index: Swift.Int, _ value: Swift.Int8)
  public static func == (lhs: Mocap4Face.KotlinByteArray, rhs: Mocap4Face.KotlinByteArray) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinIntArray : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ size: Swift.Int)
  convenience public init(_ size: Swift.Int, _ init: @escaping (Swift.Int) -> Swift.Int)
  public var size: Swift.Int {
    get
  }
  public func get(_ index: Swift.Int) -> Swift.Int
  public func iterator() -> Mocap4Face.KotlinIntIterator
  public func set(_ index: Swift.Int, _ value: Swift.Int)
  public static func == (lhs: Mocap4Face.KotlinIntArray, rhs: Mocap4Face.KotlinIntArray) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol KotlinAppendable {
  var _wrappedKotlinAppendable: Swift.AnyObject { get }
  func append(_ value: Foundation.unichar) -> Mocap4Face.KotlinAppendable
  func append(_ value_: Any?) -> Mocap4Face.KotlinAppendable
  func append(_ value: Any?, _ startIndex: Swift.Int, _ endIndex: Swift.Int) -> Mocap4Face.KotlinAppendable
}
@_hasMissingDesignatedInitializers public class KotlinAppendableWrapper : Mocap4Face.ConvertibleToKotlin, Mocap4Face.KotlinAppendable {
  public var _wrappedKotlinAppendable: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func append(_ value: Foundation.unichar) -> Mocap4Face.KotlinAppendable
  public func append(_ value_: Any?) -> Mocap4Face.KotlinAppendable
  public func append(_ value: Any?, _ startIndex: Swift.Int, _ endIndex: Swift.Int) -> Mocap4Face.KotlinAppendable
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KotlinStringBuilder : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.KotlinAppendable {
  public var _wrappedKotlinAppendable: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  convenience public init(_ capacity: Swift.Int)
  convenience public init(_ content: Swift.String)
  convenience public init(_ content_: Any)
  public var length: Swift.Int {
    get
  }
  public func append(_ value__: Any?) -> Mocap4Face.KotlinStringBuilder
  public func append(_ value___: Swift.Bool) -> Mocap4Face.KotlinStringBuilder
  public func append(_ value____: Swift.Int8) -> Mocap4Face.KotlinStringBuilder
  public func append(_ value: Foundation.unichar) -> Mocap4Face.KotlinAppendable
  public func append(_ value_____: Mocap4Face.KotlinCharArray) -> Mocap4Face.KotlinStringBuilder
  public func append(_ value: Any?, _ startIndex: Swift.Int, _ endIndex: Swift.Int) -> Mocap4Face.KotlinAppendable
  public func append(_ value______: Swift.Double) -> Mocap4Face.KotlinStringBuilder
  public func append(_ value_______: Swift.Float) -> Mocap4Face.KotlinStringBuilder
  public func append(_ value________: Swift.Int) -> Mocap4Face.KotlinStringBuilder
  public func append(_ value_________: Swift.Int64) -> Mocap4Face.KotlinStringBuilder
  public func append(_ value__________: Swift.Int16) -> Mocap4Face.KotlinStringBuilder
  public func append(_ value___________: Swift.String?) -> Mocap4Face.KotlinStringBuilder
  public func appendRange(_ value: Mocap4Face.KotlinCharArray, _ startIndex: Swift.Int, _ endIndex: Swift.Int) -> Mocap4Face.KotlinStringBuilder
  public func appendRange(_ value: Any, _ startIndex: Swift.Int, _ endIndex_: Swift.Int) -> Mocap4Face.KotlinStringBuilder
  public func capacity() -> Swift.Int
  public func deleteAt(_ index: Swift.Int) -> Mocap4Face.KotlinStringBuilder
  public func deleteRange(_ startIndex: Swift.Int, _ endIndex: Swift.Int) -> Mocap4Face.KotlinStringBuilder
  public func ensureCapacity(_ minimumCapacity: Swift.Int)
  public func get(_ index__: Swift.Int) -> Foundation.unichar
  public func indexOf(_ string: Swift.String) -> Swift.Int
  public func indexOf(_ string: Swift.String, _ startIndex: Swift.Int) -> Swift.Int
  public func insert(_ index: Swift.Int, _ value: Any?) -> Mocap4Face.KotlinStringBuilder
  public func insert(_ index: Swift.Int, _ value_: Swift.Bool) -> Mocap4Face.KotlinStringBuilder
  public func insert(_ index: Swift.Int, _ value__: Swift.Int8) -> Mocap4Face.KotlinStringBuilder
  public func insert(_ index: Swift.Int, _ value___: Foundation.unichar) -> Mocap4Face.KotlinStringBuilder
  public func insert(_ index: Swift.Int, _ value____: Mocap4Face.KotlinCharArray) -> Mocap4Face.KotlinStringBuilder
  public func insert(_ index: Swift.Int, _ value______: Swift.Double) -> Mocap4Face.KotlinStringBuilder
  public func insert(_ index: Swift.Int, _ value_______: Swift.Float) -> Mocap4Face.KotlinStringBuilder
  public func insert(_ index: Swift.Int, _ value________: Swift.Int) -> Mocap4Face.KotlinStringBuilder
  public func insert(_ index: Swift.Int, _ value_________: Swift.Int64) -> Mocap4Face.KotlinStringBuilder
  public func insert(_ index: Swift.Int, _ value__________: Swift.Int16) -> Mocap4Face.KotlinStringBuilder
  public func insert(_ index: Swift.Int, _ value___________: Swift.String?) -> Mocap4Face.KotlinStringBuilder
  public func insertRange(_ index: Swift.Int, _ value: Mocap4Face.KotlinCharArray, _ startIndex: Swift.Int, _ endIndex: Swift.Int) -> Mocap4Face.KotlinStringBuilder
  public func insertRange(_ index: Swift.Int, _ value: Any, _ startIndex: Swift.Int, _ endIndex_: Swift.Int) -> Mocap4Face.KotlinStringBuilder
  public func lastIndexOf(_ string: Swift.String) -> Swift.Int
  public func lastIndexOf(_ string: Swift.String, _ startIndex: Swift.Int) -> Swift.Int
  public func reverse() -> Mocap4Face.KotlinStringBuilder
  public func set(_ index: Swift.Int, _ value: Foundation.unichar)
  public func setLength(_ newLength: Swift.Int)
  public func setRange(_ startIndex: Swift.Int, _ endIndex: Swift.Int, _ value: Swift.String) -> Mocap4Face.KotlinStringBuilder
  public func subSequence(_ startIndex: Swift.Int, _ endIndex: Swift.Int) -> Any
  public func substring(_ startIndex: Swift.Int) -> Swift.String
  public func substring(_ startIndex: Swift.Int, _ endIndex: Swift.Int) -> Swift.String
  public func toCharArray(_ destination: Mocap4Face.KotlinCharArray, _ destinationOffset: Swift.Int, _ startIndex: Swift.Int, _ endIndex: Swift.Int)
  public func description() -> Swift.String
  public func trimToSize()
  public func append(_ value_: Any?) -> Mocap4Face.KotlinAppendable
  public static func == (lhs: Mocap4Face.KotlinStringBuilder, rhs: Mocap4Face.KotlinStringBuilder) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinPair<A, B> : Mocap4Face.ConvertibleToKotlin {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ first: A, _ second: B)
  public var first: A {
    get
  }
  public var second: B {
    get
  }
  public func component1() -> A
  public func component2() -> B
  public func doCopy(_ first: A, _ second: B) -> Mocap4Face.KotlinPair<A, B>
  public func equals(_ other: Any?) -> Swift.Bool
  public func hashCode() -> Swift.Int
  public func toString() -> Swift.String
  public static func == (lhs: Mocap4Face.KotlinPair<A, B>, rhs: Mocap4Face.KotlinPair<A, B>) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol KotlinIterator {
  associatedtype T
  var _wrappedKotlinIterator: Swift.AnyObject { get }
  func hasNext() -> Swift.Bool
  func next() -> Self.T
}
@_hasMissingDesignatedInitializers public class KotlinIteratorWrapper<T> : Mocap4Face.ConvertibleToKotlin, Mocap4Face.KotlinIterator {
  public typealias T = T
  public var _wrappedKotlinIterator: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public func hasNext() -> Swift.Bool
  public func next() -> T
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KotlinFloatIterator : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.KotlinIterator {
  public typealias T = Swift.Float
  public var _wrappedKotlinIterator: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func next() -> Mocap4Face.KotlinFloatIterator.T
  public func nextFloat() -> Swift.Float
  public func hasNext() -> Swift.Bool
  public static func == (lhs: Mocap4Face.KotlinFloatIterator, rhs: Mocap4Face.KotlinFloatIterator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinDoubleArray : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ size: Swift.Int)
  convenience public init(_ size: Swift.Int, _ init: @escaping (Swift.Int) -> Swift.Double)
  public var size: Swift.Int {
    get
  }
  public func get(_ index: Swift.Int) -> Swift.Double
  public func iterator() -> Mocap4Face.KotlinDoubleIterator
  public func set(_ index: Swift.Int, _ value: Swift.Double)
  public static func == (lhs: Mocap4Face.KotlinDoubleArray, rhs: Mocap4Face.KotlinDoubleArray) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
public protocol KotlinLazy {
  associatedtype T
  var _wrappedKotlinLazy: Swift.AnyObject { get }
  var value: Self.T { get }
  func isInitialized() -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class KotlinLazyWrapper<T> : Mocap4Face.ConvertibleToKotlin, Mocap4Face.KotlinLazy {
  public typealias T = T
  public var _wrappedKotlinLazy: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  public var value: T {
    get
  }
  public func isInitialized() -> Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers public class KotlinByteIterator : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.KotlinIterator {
  public typealias T = Swift.CChar
  public var _wrappedKotlinIterator: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func next() -> Mocap4Face.KotlinByteIterator.T
  public func nextByte() -> Swift.Int8
  public func hasNext() -> Swift.Bool
  public static func == (lhs: Mocap4Face.KotlinByteIterator, rhs: Mocap4Face.KotlinByteIterator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinIntIterator : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.KotlinIterator {
  public typealias T = Swift.Int
  public var _wrappedKotlinIterator: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func next() -> Mocap4Face.KotlinIntIterator.T
  public func nextInt() -> Swift.Int
  public func hasNext() -> Swift.Bool
  public static func == (lhs: Mocap4Face.KotlinIntIterator, rhs: Mocap4Face.KotlinIntIterator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinCharArray : Mocap4Face.ConvertibleToKotlin, Swift.Hashable {
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init(_ size: Swift.Int)
  convenience public init(_ size: Swift.Int, _ init: @escaping (Swift.Int) -> Any)
  public var size: Swift.Int {
    get
  }
  public func get(_ index: Swift.Int) -> Foundation.unichar
  public func iterator() -> Mocap4Face.KotlinCharIterator
  public func set(_ index: Swift.Int, _ value: Foundation.unichar)
  public static func == (lhs: Mocap4Face.KotlinCharArray, rhs: Mocap4Face.KotlinCharArray) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinDoubleIterator : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.KotlinIterator {
  public typealias T = Swift.Double
  public var _wrappedKotlinIterator: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func next() -> Mocap4Face.KotlinDoubleIterator.T
  public func nextDouble() -> Swift.Double
  public func hasNext() -> Swift.Bool
  public static func == (lhs: Mocap4Face.KotlinDoubleIterator, rhs: Mocap4Face.KotlinDoubleIterator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class KotlinCharIterator : Mocap4Face.ConvertibleToKotlin, Swift.Hashable, Mocap4Face.KotlinIterator {
  public typealias T = Any
  public var _wrappedKotlinIterator: Swift.AnyObject {
    get
  }
  convenience required public init(_ wrapped: Mocap4Face.KotlinObjectWrapper)
  public func asKotlin() -> Swift.AnyObject
  convenience public init()
  public func next() -> Mocap4Face.KotlinCharIterator.T
  public func nextChar() -> Foundation.unichar
  public func hasNext() -> Swift.Bool
  public static func == (lhs: Mocap4Face.KotlinCharIterator, rhs: Mocap4Face.KotlinCharIterator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  @objc deinit
  public var hashValue: Swift.Int {
    get
  }
}
extension FaceTracker {
  public static func createVideoTracker() -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.FaceTracker>>
  public static func createImageTracker() -> Mocap4Face.Future<Mocap4Face.Try<Mocap4Face.FaceTracker>>
  public func track(_ image: CoreVideo.CVPixelBuffer?) -> Mocap4Face.FaceTrackerResult?
  public func track(_ image: CoreMedia.CMSampleBuffer?) -> Mocap4Face.FaceTrackerResult?
  public func track(_ image: UIKit.UIImage?) -> Mocap4Face.FaceTrackerResult?
}
extension Mocap4Face.MetalTextureView.Rotation : Swift.Equatable {}
extension Mocap4Face.MetalTextureView.Rotation : Swift.Hashable {}
extension Mocap4Face.MetalTextureView.Rotation : Swift.RawRepresentable {}
extension Mocap4Face.ByteOrder : Swift.Equatable {}
extension Mocap4Face.ByteOrder : Swift.Hashable {}
extension Mocap4Face.Tuple1 : Swift.Hashable {}
extension Mocap4Face.Tuple2 : Swift.Hashable {}
extension Mocap4Face.Tuple3 : Swift.Hashable {}
extension Mocap4Face.Tuple4 : Swift.Hashable {}
extension Mocap4Face.Tuple5 : Swift.Hashable {}
extension Mocap4Face.Tuple6 : Swift.Hashable {}
extension Mocap4Face.Tuple7 : Swift.Hashable {}
extension Mocap4Face.Tuple8 : Swift.Hashable {}
extension Mocap4Face.LogLevel : Swift.Equatable {}
extension Mocap4Face.LogLevel : Swift.Hashable {}
extension Mocap4Face.FillMode : Swift.Equatable {}
extension Mocap4Face.FillMode : Swift.Hashable {}
extension Mocap4Face.PixelComponents : Swift.Equatable {}
extension Mocap4Face.PixelComponents : Swift.Hashable {}
extension Mocap4Face.FaceTrackerResult : Swift.Hashable {}
extension Mocap4Face.FaceTrackerWithResult : Swift.Hashable {}
extension Mocap4Face.FaceTrackerReprojectorResult : Swift.Hashable {}
extension Mocap4Face.FileWatchErrorSensitivity : Swift.Equatable {}
extension Mocap4Face.FileWatchErrorSensitivity : Swift.Hashable {}
extension Mocap4Face.Path : Swift.Hashable {}
extension Mocap4Face.KotlinPair : Swift.Hashable {}